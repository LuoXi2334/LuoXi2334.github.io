---
title: 运算符
date: 2022-11-17 16:00:00
description: 洛希的十一月份笔记内容
categories: c语言
tag: C语言
---

# 运算符



## 1算数运算符

### ①基本运算符

![image-20221115232423272](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/image-20221115232423272.png)

**注：除法的第一个５／３后面的结果是直接舍弃了小数，而５．０／３．０保留了小数。即为整数／整数＝整数，浮点数／浮点数＝浮点数。还有求余运算符必须是两个整数，除此之外，我们能看上表有相关双目和单目的内容，那么，我们应该怎么判断单目还有双目呢？**

### ②目

#### （1）分类

**1.单目运算符**：如正、负号，逻辑运算符

**2.双目运算符**：算术运算符、关系运算符

**3.三目运算符**：条件运算符

#### （2）判断方法

如以下的例子

```c
1+2//操作符+运算符+操作数//双目
 +5//运算符+操作数//单目
```

根据以上的例子我们可以得知`，判断为双目还是单目取决于操作数的数量`

### ③表达式

用运算符和括号将操作数连接起来的式子，我们称之为表达式。如下面例子所示

```c
1+1
'a'+'b'
a+b
a+'b'+pow(a,b)*3/4+5
```

### ④运算符的优先级和结合性

![image-20221115234543096](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/image-20221115234543096.png)

下面用一串代码来说明下运算符的优先级

```c
#include<stdio.h>
#include<math.h>//使得pow函数实现，所以必须引出
int main ()
{
int a, b, c;
a=1+2;
b=1+2*3;
c=a+b+-1+pow(2,3);//pow函数的作用就是给括号内的数字幂指数，pow（底数，幂指数），本复杂运算的数学表达是a+b+（-1）+2^3
printf("a=%d\nb=%d\nc=%d\n",a,b,c);    
return 0 ;
}
```

最后的打印结果如下

![image-20221116000955540](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/image-20221116000955540.png)

### ⑤类型转换

当一个运算符的几个操作数类型不同的时候，会发生什么呢？比如以下例子

```c
1+2.0=？//最后结果将是什么数据类型呢？
 1+2.0`1.0+2.0=3.0//最后答案为浮点型，这又是为什么呢？
```

通常情况下，`编译器会将占用内存较小的那个操作数先转换为占用内存较大的操作数`的数据类型，然后再进行运算。这样做的`目的是为了确保计算的精度`。如果是把浮点型转换为整形的话如1.2+1这样的表达式，按照这种运算会直接把小数给舍弃就变成了1，那么它的结果变成了1+1=2了。以下用一串代码来进行理解。

```c
#include<stdio.h>
int main ()
{
printf("整形输出：%d\n",1+2.0);
printf("浮点型输出：%f\n",1+2.0);
return 0 ;
}
```

以下为打印结果

![image-20221116001334769](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/image-20221116001334769.png)

如果强制使它输入整形的结果贼会出现一个错误的答案，可是程序员是活的，我们可不可以用个办法强制让它输出的结果为整形呢？我们来看以下的代码

```c
#include<stdio.h>
int main()
{
	printf("整形输出：%d\n", 1 + (int)1.8);//数字前面加个（数据类型）可以进行强制的转换
	return 0;
}
```

以下为打印出来的结果

![image-20221116002434617](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/image-20221116002434617.png)

很明显，我们强制把1.8转换为整形之后损失了精度，直接少了0.8。



## 2.关系运算符

### ①分支结构

#### （1）功能

`对程序进行判断和抉择`，比如判断用户是否为18岁以及用户是否为男性或者女性等等....这种相关的设计我们称为分支结构设计。

### ②六大关系运算符

利用关系运算符来比较两个数的大小关系：

| 优先级相同（高） | 优先级相同（低） |
| :--------------: | :--------------: |
|    <（小于）     |    `（等于）    |
| <=（小于或等于） |  ！=（不等于）   |
|    >（大于）     |                  |
|  >=(大于或等于)  |                  |

### ③关系表达式

#### （1）定义

`用关系运算符将两边的变量、数据或表达式连接起来，称之为关系表达式。`

#### （2）逻辑值

而在关系表达式中得到的值是一个`逻辑值`，即真或假，在c语言的逻辑运算中，`用数字1表示真，数字0表示假`。

比如以下的例子。

```c
1<2//该关系式为真，所以该关系式的值为1
a>b
a<=1+b
'a'+'b'<='c'//根据ASCII码表分别是97，98，99，即为97+98<=99，所以该关系式为假，关系式的值为0
(a=3)>(b=5)
```

我们用一串代码来进行理解逻辑值吧！

```c
#include <stdio.h>
int main ()
{
int a = 5;
int b = 3;
printf("%d\n",1<2);
printf("%d\n",a>b);
printf("%d\n",a<=b+1);
printf("%d\n",'a'+'b'<='c');
printf("%d\n",(a=3)>(b=5));
return 0 ;
}
```

下面为打印出来的结果

![image-20221116170318778](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/image-20221116170318778.png)

很明显我们可以看到，以上的结果只有1和0，对应的正是逻辑值的1和0来表达式子的真假。

### 3.逻辑运算符

#### ①三大逻辑运算符

![image-20221116170909641](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/image-20221116170909641.png)

#### ②逻辑表达式

用逻辑运算符将两边的变量，数据或表达式连接起来，称之为逻辑表达式。如以下的例子。

```c
3 > 1 && 1 < 2
3 + 1 || 2 ` 0//3+1！= 0所以为真
! (a+b)
! 0 + 1 < 1 || ! (3+4)
'a' - 'b' && 'c'
```

一样，下面用一串代码来进行理解

```c
#include <stdio.h>
int main ()
{
 int a=5, b=3;
printf("%d\n",3 > 1 && 1 < 2);
printf("%d\n",3 + 1 || 2 ` 0);
printf("%d\n",! (a+b));
printf("%d\n",! 0 + 1 < 1 || ! (3+4));
printf("%d\n",'a' - 'b' && 'c');
return 0 ;
}
```

下图为打印出来的结果

![image-20221116172218462](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/image-20221116172218462.png)

#### ③短路求值

`短路求值又称为最小化求值`，是一种逻辑运算符的求值策略。只有当第一个运算符的值无法确定逻辑运算的结果时，才对第二个运算数进行求值。

`C语言对宇逻辑与逻辑或采用短路求值的方法`。

下面用一串代码来进行理解短路求值

```c
#include <stdio.h>
int main ()
{
int a=2,b=3;
(a=0) && (b=5);//逻辑与要求左边和右边同时成立，且因为对于第一个值可以知道a=0为假，则左边不成立，右边将不进行运算。所以5不会赋值给b而是保留了原来的3
printf("a=%d, b=%d\n",a,b);
(a=1) || (b=5);//逻辑或要求左边和右边任何一边成立即可，且对于左边a=1，而1是真所以左边成立，右边将不进行运算。所以5不会赋值给b而是保留了原来的3
printf("a=%d, b=%d\n",a,b);
return 0;
}
```

以下为打印结果

![image-20221116173810752](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/image-20221116173810752.png)

