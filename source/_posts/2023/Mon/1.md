---
title: 函数
date: 2023-1-3 16:00:00
description: 洛希的一月份笔记内容
categories: c语言
tag: C语言
swiper_index: 1 
---

# 函数

## ①目前开发的问题

**随着程序规模的变大：**

1.`main函数变得相当冗杂`

2.程序复杂度不断提高

3.代码前后关联度高，修改代码往往牵一发而动全身

4.变量的命名都成了问题

5.为了在程序中多次实现某些功能，不得不重复写相同的代码

## ②主函数外的函数

### （1）定义

```c
//类型名一定程度决定了返回值。
类型名 函数名（参数列表）
{
    //执行过程
    函数体
}
```

### （2）声明

所谓声明，就说高速编译器我们使用这个函数，你现在没用找到它千万不要着急报错，稍后就把定义补上。

```c
类型名 函数名（参数列表）;//可以省略，但是不建议。
```

**注意：因为编译器是从下到上执行，如果你的函数定义写在主函数下方，建议还是要把定义写上，这是给良好的习惯，**

### （3）函数的参数和返回值

函数的参数就说参数列表对应的`形式参数`，返回值则是代表这个`函数的结束`，返回为某值。但是一定要注意`函数返回值的类型由函数首部定义的类型决定`！

## （4）例子

对于①中5所提到的，如果我们想要重复打印一段文字，应该怎么做呢？先举个简单的小例子

```c
#include <stdio.h>
//声明函数printc
void printc();
//定义函数printc
void printc()
{
printf("6");
}
int main()
{
printc();//调用函数printc
return 0;
}
```

对于这个代码，我们在主函数外定义了一个函数printc，让它帮我们打印一些内容，以下为输出结果。

![image-20230104004745848](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040047979.png)

如果我们想要这个函数的内容执行三次，只需要额外再调用两次就可以了。

```c
#include <stdio.h>
void printc();//定义函数print-c
void printc()
{
printf("6");
}
int main()
{
printc();//调用函数printc
printc();
printc();
//调用三次printc
return 0;
}
```

输出结果如下所示

![image-20230104004928446](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040049509.png)

但是，如果我们想要它无限调用这个函数的话，我们该怎么办呢？这就不得不用到所谓的`递归`思想了。递归和迭代有一点相似，但是它们不完全相同。

**递归:函数直接或间接调用函数自身,`直到满足终止条件`,再`逐层回归`。**

**迭代:利用已知的变量值,不断用变量的旧值递推新值,`直到到达结束状态`**

所以，如果我们想要无限调用函数printc只需要在printc里面继续调用就行了。

```c
#include <stdio.h>
void printc();//定义函数print-c
void printc()
{
printf("6");
printc();
}
int main()
{
printc();//调用函数printc
return 0;
}
```

输出结果如下所示

![image-20230104005317112](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040053178.png)

递归的思想在很多地方也很适用，不过有一个非常经典的例子是有关一个小游戏名叫`汉诺塔`。

对于以上的例子是函数一个简单的小例子，如果我们想写一个函数帮忙我们计算阶乘的话？该如何写呢？代码如下。

```c
#include <stdio.h>
int fact(int n);
int fact(int n)
{
  int s = 1;
  for (int i = 1; i <= n; i++)
  {
    s *= i;
  }
  // 返回值必须是整数
  return s;
}
int main()
{
  int n;
  printf("请输入一个数：");
  scanf("%d", &n);
  // 在printf里面调用fact函数
  printf("它的阶乘为%d\n", fact(n));
  return 0;
}
```

对于以上代码，我们输入5来测试下。

![image-20230104014550984](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040145060.png)

## ③递归思想——汉诺塔问题

**以下是一个汉诺塔的有关问题**:

  相传在古印度圣庙中，有一种被称为汉诺塔的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘。                                          

游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。

如果，我们将金盘的数量定义为n，要求用代码实现移动过程，该怎么办呢？

![image-20230104010148248](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040101310.png)

**思路：**

1.如果要**把A中的n个金盘借助B移动到C去**，且满足小在上大在下的规则的话，我们第一肯定是要把`n盘上面的n-1个金盘借助C移动到B`，然后就可以将n盘移动到C去了。

2.此时问题变成了要**把B中的n-1个金盘借助A移动到C去**，则是要把`n-2个金盘借助C移动到A去`，然后就可以把n-1盘移动到C去了。

3.此时问题就变成了**把A中的n-2个金盘借助B移动到C去**，则思路一样，是要把`n-3个金盘借助C移动到B去`，然后就可以将n-2盘移动到C去了。

通过上面的3次分析，我们发现其实这个问题的本质就是每个分析标注的两点以及下个分析的第一个标注点，此时核心问题为如下三点。

**①把A中的n个金盘借助B移动到C去**

**②n盘上面的n-1个金盘借助C移动到B**

**③把B中的n-1个金盘借助A移动到C去**

那我们应该如何去用代码实现呢？

此中我们需要定义金盘的数量这个变量，以及表述A,B,C三个柱子的变量。然后根据`递归思想`（根据上面分析，问题是一种重复的轮回。）去实现它。

**题解：**

```c
#include <stdio.h>
// 定义一个实现这个流程的函数，函数括号的意思是(金盘数量，柱子a(起始)，柱子b(借助)，柱子c(终点))
// 而后面的三个字符变量后面的思路就是借助柱子b把金盘从柱子a移动到柱子c。
// 注意：前往别把这三个柱子定死理解为就说ABC柱子，后面会有调用函数的交换。
void halot(int n, char a, char b, char c);
void halot(int n, char a, char b, char c)
{
  // 当此时只剩下一个盘的时候，只需要完成此时的目标，比如n-1个盘子以及到B柱子，这里n盘这一个盘就直接去目标。
  if (n == 1)
  {
    // 表示这个移动的过程，根据调用这个函数就是为了实现移动的这个过程。
    printf("%c --＞ %c\n", a, c);
  }
  else
  {
    // 交换b和c的字符导致字符变量a，b，c并非代表了柱子ABC，但是思路还是和上面所说一样
    halot(n - 1, a, c, b);
    // 表示这个移动的过程，根据调用这个函数就是为了实现移动的这个过程。
    printf("%c --＞ %c\n", a, c);
    // 交换b和a的字符导致字符变量a，b，c并非代表了柱子ABC，但是思路还是和上面所说一样
    halot(n - 1, b, a, c);
  }
}
int main(void)
{
  int n;
  printf("请输入金盘的数量:");
  scanf("%d", &n);
  halot(n, 'A', 'B', 'C'); // 将形参a命定为柱子A，形参b命定为柱子B，形参c命定为柱子C。
  return 0;
}
```

**注意：**请不要定死了字符变量a，b，c所代表的柱子，它们在调用函数的时候会改变，但是**核心思想永远不变**！

代码的输出结果如下所示，测试数据为3

![image-20230104012610506](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040126575.png)

最后根据这个步骤，游戏圆满成功！
![image-20230104012701255](https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040127312.png)