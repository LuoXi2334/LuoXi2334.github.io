<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛希の智慧之殿堂</title>
  
  <subtitle>洛希的小窝</subtitle>
  <link href="https://bg.luoxi.work/atom.xml" rel="self"/>
  
  <link href="https://bg.luoxi.work/"/>
  <updated>2023-07-27T16:36:28.828Z</updated>
  <id>https://bg.luoxi.work/</id>
  
  <author>
    <name>洛希</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Q群云崽机器人的基本使用教程</title>
    <link href="https://bg.luoxi.work/2023/07/27/2023/July/1/"/>
    <id>https://bg.luoxi.work/2023/07/27/2023/July/1/</id>
    <published>2023-07-27T14:00:00.000Z</published>
    <updated>2023-07-27T16:36:28.828Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Q群机器人基本使用教程"><a href="#Q群机器人基本使用教程" class="headerlink" title="Q群机器人基本使用教程"></a>Q群机器人基本使用教程</h1><p>这个教程就是针对于本人根据<strong>云崽框架</strong>搭建的QQ机器人的相关使用教程，教程如下</p><h2 id="一、机器人基本介绍"><a href="#一、机器人基本介绍" class="headerlink" title="一、机器人基本介绍"></a>一、机器人基本介绍</h2><p>机器人在Q群里面的名称叫做纳西妲（因为群主是纳西妲单推人），QQ号是1461277498，里面的很多功能在群聊也可以用，私聊一样可以。所以可以加机器人QQ，使用我用Chatgpt-plugin插件内置的gpt功能，也可以在群里面@机器人然后发你想询问的信息就可以。</p><p><strong>机器人内置插件如下图</strong>：</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272302413.png" alt="image-20230727230210188"></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272302677.png" alt="image-20230727230220582"></p><p>很多的插件都有相应的功能，<strong>一般的插件都会有对应功能的帮助面板</strong>，当然里面也只有一些常用的插件。</p><h2 id="二、插件帮助面板"><a href="#二、插件帮助面板" class="headerlink" title="二、插件帮助面板"></a>二、插件帮助面板</h2><p>对机器人发送对应的像（#{name}帮助）的<strong>指令</strong>就可以唤起对应的帮助面板，比如我机器人默认的就是喵喵插件的帮助，就可以发送<code>#帮助</code>或者<code>#喵喵帮助</code>得到对应的功能面板，如下图展示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272305660.png" alt="image-20230727230549577"></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272305036.png" alt="image-20230727230557952"></p><p>这里面{name}就是填写对应插件的名字，然后发送成功后就可以得到对应的帮助面板，本群常用的有<strong>喵喵插件、星铁插件、土块插件、枫叶插件等等</strong>。如果你要唤起星铁插件的帮助面板就发<code>#星铁帮助</code>，如果你要土块插件的帮助面板就发<code>#土块帮助</code>其他的同理。还有就是本群很多的插件功能面板图都在群精华信息内。</p><h2 id="三、如何使用插件帮助面板图的功能"><a href="#三、如何使用插件帮助面板图的功能" class="headerlink" title="三、如何使用插件帮助面板图的功能"></a>三、如何使用插件帮助面板图的功能</h2><p>以喵喵帮助面板的功能为例子</p><p>喵喵插件有很多栏的功能，我们先来看第三栏</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272316673.png" alt="image-20230727231608460"></p><p>上面的这些功能只要按照上面的提示输入就可以让机器人回复对应功能得到的结果，比如第一个<code>#体力</code>，就只需要对机器人，或者在群聊哪里发出对应的指令即可，比如看以下的操作</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272325460.png" alt="image-20230727232506346"></p><p>这个就是查询体力的服务，但是一般一开始没有这个功能，这个功能需要<strong>绑定cookie</strong>，这个的话在四再细说怎么绑定。帮助面板上面有很多功能都可以根据相关提示去使用，有兴趣的话可以都试着私聊机器人或者在群聊里面进行发送。</p><p>另外在介绍下ai绘图的帮助，ai绘图帮助的话是基于土块插件帮助的一个功能帮助，需要对机器人发送<code>#画图帮助</code>就可以得到对应的帮助面板</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272328204.png" alt="image-20230727232822135"></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272328750.png" alt="image-20230727232843609"></p><p>可以看到上面有很多的功能，同样的以第一个功能来举例，我们如果要使用ai#绘图的话可以对机器人发送<code>#绘个图 &#123;对应的图片描述tag&#125;</code>，比如我想要画个泳装的纳西妲的话，里面的关键词是纳西妲，泳装。此时我就要对机器人发送<code>#绘个图 纳西妲，泳装</code>，得到的结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272331438.png" alt="image-20230727233120337"></p><p>此时就得到了符合条件的ai作画！</p><h2 id="四、关于cookie以及token的绑定（stoken也可以用于星铁cookie的绑定）"><a href="#四、关于cookie以及token的绑定（stoken也可以用于星铁cookie的绑定）" class="headerlink" title="四、关于cookie以及token的绑定（stoken也可以用于星铁cookie的绑定）"></a>四、关于cookie以及token的绑定（stoken也可以用于星铁cookie的绑定）</h2><h3 id="1、方法一（最简单，很推荐，但最好多设备）：-扫码登录法"><a href="#1、方法一（最简单，很推荐，但最好多设备）：-扫码登录法" class="headerlink" title="1、方法一（最简单，很推荐，但最好多设备）：#扫码登录法"></a>1、方法一（最简单，很推荐，但最好多设备）：#扫码登录法</h3><p>此方法需要在一台设备上面对机器人发送<code>#扫码登录</code>，然后用另外一台设备进入米游社去扫码，其实一个设备也行，不过你要保存机器人发送给你的二维码然后再去米游社扫码，操作如下</p><p><strong>1、对机器人发送#扫码登录</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272336616.png" alt="image-20230727233603554"></p><p><strong>2、登录米游社进行扫码，尽量要快不然机器人会撤回！</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272337098.jpg" alt="Screenshot_2023-07-27-23-36-20-213_com.mihoyo.hyp"></p><p><strong>3、扫码之后并且得到下面的结果即绑定stoken和cookie全部成功！</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272349944.png" alt="image-20230727234929884"></p><h3 id="2、方法二（有点复杂，不太推荐）：token绑定法"><a href="#2、方法二（有点复杂，不太推荐）：token绑定法" class="headerlink" title="2、方法二（有点复杂，不太推荐）：token绑定法"></a>2、方法二（有点复杂，不太推荐）：token绑定法</h3><p><strong>1、下载群文件里面的软件</strong></p><p>群文件这个文件夹里面的软件</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272340216.png" alt="image-20230727234022163"></p><p><strong>2、打开该软件，并且登录账户</strong><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272342268.jpg" alt="Screenshot_2023-07-27-23-41-14-001_com.miui.home-"></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272343208.png" alt="image-20230727234310153"></p><p><strong>3、点击右上角三点进行获取token并全选复制</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272344671.png" alt="image-20230727234402619"></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280017637.png" alt="image-20230728001748561"></p><p><strong>4、私聊发送给机器人</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280018127.png" alt="img"></p><p><strong>5、按照给的提示功能面板发送#刷新ck，抽卡记录就是#更新抽卡记录（对应的查询就是，限定池#角色记录，武器池#武器记录，常驻池#常驻记录）</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272347421.png" alt="image-20230727234715364"></p><p>显示上图就说明绑定完成啦！此时喵喵面板大部分功能全部都可以进行使用了！</p><h2 id="五、一些相关补充"><a href="#五、一些相关补充" class="headerlink" title="五、一些相关补充"></a>五、一些相关补充</h2><p>这里总结的介绍下机器人的大部分插件名字，方便可以发出正确的插件面板帮助指令</p><table><thead><tr><th>插件名字</th><th>帮助指令</th></tr></thead><tbody><tr><td>喵喵插件</td><td>#喵喵帮助（#帮助）</td></tr><tr><td>土块插件</td><td>#土块帮助</td></tr><tr><td>图鉴插件</td><td>#图鉴帮助</td></tr><tr><td>枫叶插件</td><td>#枫叶帮助</td></tr><tr><td>星铁插件</td><td>#星铁帮助</td></tr><tr><td>chatgpt插件</td><td>#chatgpt帮助</td></tr><tr><td>闲心插件</td><td>#闲心帮助</td></tr><tr><td>椰奶插件</td><td>#椰奶帮助</td></tr></tbody></table><p>这些就是对应大部分插件的的帮助指令了，通过输入对应的指令就可以得到对应的功能帮助面板服务，下面还要介绍一个很常用的功能就是原神面板服务了！</p><h2 id="1、原神面板服务"><a href="#1、原神面板服务" class="headerlink" title="1、原神面板服务"></a>1、原神面板服务</h2><p>原神的面板服务是基于喵喵插件的一个功能，可以再功能图就可以看到对应的一些指令。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307272357860.png" alt="image-20230727235755745"></p><p>首先要想使用这个插件里面的面板服务的话，首先需要确认你游戏里面的资料板上面的你想要看的角色是否公开了面板，如下操作所所示</p><p><strong>1、确认游戏内已经公开你想要查询的角色面板</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280000677.png" alt="image-20230728000035486"></p><p><strong>右下角的显示角色详细一定要打开</strong>，展示的话就是你想要查询角色的面板。</p><p><strong>2、向机器人绑定你的游戏uid</strong></p><p>在前面绑定cookie的帮助局域栏的右边有个#绑定uid{你的uid}这个功能，就是对应激活这个功能的指令，比如我的游戏uid是110776530，那么操作如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280003331.png" alt="image-20230728000303269"></p><p><strong>3、发送#更新面板来进行获取</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280003437.png" alt="image-20230728000348342"></p><p>可以看到角色名字左边有个绿色圈圈就代表此角色面板已经更新，不过要<strong>注意这个面板更新的话如果此时刚刚好刚给角色换了圣遗物需要查看新圣遗物下角色的提升和分数就需要隔个5分钟左右更新，不然数据是不会更新的，更新的条件就是角色左边有个<code>小绿圈圈</code></strong></p><p><strong>4、发送#{角色名}面板来查询对应角色面板</strong></p><p>比如我要查纳西妲的面板就发送#纳西妲面板</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202307280007949.png" alt="image-20230728000756873"></p>]]></content>
    
    
    <summary type="html">经验分享</summary>
    
    
    
    <category term="经验分享" scheme="https://bg.luoxi.work/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="经验分享" scheme="https://bg.luoxi.work/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>重载</title>
    <link href="https://bg.luoxi.work/2023/06/14/2023/June/2/"/>
    <id>https://bg.luoxi.work/2023/06/14/2023/June/2/</id>
    <published>2023-06-14T08:00:00.000Z</published>
    <updated>2023-06-16T15:34:32.555Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><p>在C++中重载是<strong>对已有的运算符重新进行定义，赋予其另一种功能</strong>。比如对于不同的数据类型，像一个类中，我们想要用运算符进行两个对象的成员属性的加减操作就必须进行运算符的重载。</p><p><strong>运算符的重载包括以下几种：</strong></p><p>1、加号运算符重载</p><p>2、左移运算符重载</p><p>3、递增运算符重载</p><p>4、赋值运算符重载</p><p>5、关于运算符重载</p><p>6、函数调用运算符重载</p><h2 id="（1）加号运算符重载"><a href="#（1）加号运算符重载" class="headerlink" title="（1）加号运算符重载"></a>（1）加号运算符重载</h2><p><strong>作用：</strong>实现两个自定义数据类型相加的操作</p><p>我们通常用的加号运算符都是实现两个内置数据类型的运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> c = a + b;</span><br></pre></td></tr></table></figure><p>像上面编译器可以通过加号运算符得到c的值为15。</p><p>假如有一个<code>Person</code>的类，类中有成员属性<code>int m_age</code>,我们通过上面的运算能实现对应的功能吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">Person p3 = p1 + p2;</span><br></pre></td></tr></table></figure><p>此时编译器可能会对你说：”我不到啊！“。</p><p>因为我们没有告诉编译器应该如何去进行运算！</p><p>其实对于上面这个功能的实现的话，我们可以写一个类内的<code>PersonAddAge</code>的成员函数，然后返回值为一个新的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">PersonAddAge</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_age = <span class="keyword">this</span>-&gt;m_age + p.m_age;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码的实现之后，我们就可以实现对两个对象中的成员属性进行相加的操作。</p><p>其实在C++中如果我们要实现<code>p1 + p2</code>同等于上面成员函数的功能很简单，只需要用一个通用名称<code>operator+</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>+(person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_age = <span class="keyword">this</span>-&gt;m_age + p.m_age;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就做到了通过<strong>成员函数重载加号</strong>。</p><p>如果我们要实现通过<strong>全局函数重载加号</strong>，又该如何去做呢？</p><p>其实这个实现就和上面差不多，就我们写一个类外的全局函数来实现以上的功能，然后再将函数名替换成<code>operator+</code>,如以下的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原函数</span></span><br><span class="line"><span class="function">Person <span class="title">PersonAddAge</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_age = p1.m_age + p2.m_age;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载后</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1, Person &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_age = p1.m_age + p2.m_age;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实对于成员函数重载的本质就是对于以下内容的简化</p><p><code>Person p3 = p1.opeartor+(p2);</code> 同等于 <code>Person p3 = p1 + p2;</code></p><p>通过上面加号的举例，其实后面减号，乘号，除号都类似，实现步骤都一模一样。</p><h2 id="（2）左移运算符重载"><a href="#（2）左移运算符重载" class="headerlink" title="（2）左移运算符重载"></a>（2）左移运算符重载</h2><p>可能很多人都认为加号的运算符重载很简单，那么对于左移的运算符就差不多只需要写一个函数实现然后再更改函数名称就完事了。如果你是怎么认为的，恭喜你，大错特错。这是为什么呢？我们来看看左移运算符在我们平时的运用。</p><p>我们通过会用到左移运算符 <code>&lt;&lt;</code>来进行文本的输出，比如如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>这时候我们就会发现，这行代码里面不仅仅只有<code>&lt;&lt;</code>还有<code>cout</code>!</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202306142035831.png" alt="image-20230614203520641"></p><p>通过搜索我们发现<code>cout</code>是<code>ostream</code>类的一个实例，所以我们重载的时候也要把它带上</p><p>如果我们要通过对左移运算符的重载来打印类中的属性的话，那么是否还和上面加号运算符一样可以利用成员函数进行重载呢？</p><p>若我们要在类中利用成员函数来进行函数运算符的重载的话，来看下面的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;cout)</span><br><span class="line">&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;m_age = &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后来写对应的实现</p><p><code>p.opeartor&lt;&lt;(std::cout)</code>,我们会发现这个等价于<code>p &lt;&lt; std::cout</code></p><p>以上就没有达到我们想要的要求</p><p><strong>所以，对于左移运算符的重载最好是在全局函数中进行</strong></p><p>具体的实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;cout, Person p)</span><br><span class="line">&#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;m_age = &quot;</span> &lt;&lt; p.m_age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line">cout &lt;&lt; p;</span><br></pre></td></tr></table></figure><p>通过上面我们还发现一点点小问题，就是我们实现的时候无法加上&lt;<code>&lt;endl</code>即进行链式调用;这样会导致报错，那么应该怎么办呢？</p><p>其实只需要函数的返回值为一个<code>ostream</code>类的对象就行，具体修改如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有通过引用的方式才允许链式调用即可以在后面进行追加&lt;&lt;endl类似的操作</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;cout, Person p)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;m_age = &quot;</span> &lt;&lt; p.m_age;</span><br><span class="line">    <span class="keyword">return</span> std::cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这样我们就可自由的实现链式调用了。</p><h2 id="（3）递增运算符重载"><a href="#（3）递增运算符重载" class="headerlink" title="（3）递增运算符重载"></a>（3）递增运算符重载</h2><p>递增运算符和前面的左移运算符一样，都需要允许链式调用，所以函数类型都是以引用的方式。</p><p>不过对于递增运算符分为两种情况，一种是<code>a++</code>这种先进行运算，在进行加一。而另一种<code>++a</code>要求的是先进行加一操作，再进行运算。</p><p>如果我们要自定义一个类表示自定义的整形<code>Myint</code>，具体类如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//加上有参构造让其能隐式转换</span></span><br><span class="line">    <span class="built_in">Myint</span>(<span class="type">int</span> a) : <span class="built_in">m_a</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先是对于<code>a++</code>这种类型的重载，具体如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; oper</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">洛希的六月份笔记内容</summary>
    
    
    
    <category term="C++" scheme="https://bg.luoxi.work/categories/C/"/>
    
    
    <category term="类和对象" scheme="https://bg.luoxi.work/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>友元</title>
    <link href="https://bg.luoxi.work/2023/06/01/2023/June/1/"/>
    <id>https://bg.luoxi.work/2023/06/01/2023/June/1/</id>
    <published>2023-06-01T08:00:00.000Z</published>
    <updated>2023-05-30T08:14:50.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h1><p>有这么一个例子，如果有一个客人来到你家，首先你会叫他到客厅坐坐，而此时的客厅其实相当于一个类中public权限的一个成员。但是，如果这个客人是你的好朋友或者是你喜欢的人，你会允许他们进你的卧室，而此时的卧室相当于一个类中的private权限的一个成员。</p><p>在C++中，如果我们想要让一些<code>类外特殊的一些函数或者类</code>进行访问，此时就要用到<code>友元</code>的技术。</p><p><strong>功能</strong>：能让一个函数或者类访问另一个类中的私有成员</p><p><strong>关键字</strong>：friend</p><p><strong>实现</strong>：</p><p>1、全局函数做友元</p><p>2、类做友元</p><p>3、成员函数做友元</p><h2 id="（1）全局函数做友元"><a href="#（1）全局函数做友元" class="headerlink" title="（1）全局函数做友元"></a>（1）全局函数做友元</h2><p>全局函数做友元的操作很简单，我们根据上面的例子来写个代码就能很好的理解了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类中将全局函数GoodGuy这个函数添加为一个友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGuy</span><span class="params">(Building *bu)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 利用初始化列表对类中的属性进行初始化</span></span><br><span class="line">    <span class="built_in">Building</span>() : <span class="built_in">sittingroom</span>(<span class="string">&quot;客厅&quot;</span>), <span class="built_in">bedroom</span>(<span class="string">&quot;卧室&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string sittingroom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGuy</span><span class="params">(Building *bu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你的好基友正在访问你的&quot;</span> &lt;&lt; bu-&gt;sittingroom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你的好基友正在访问你的&quot;</span> &lt;&lt; bu-&gt;bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Building *bu = <span class="keyword">new</span> Building;</span><br><span class="line">    <span class="built_in">GoodGuy</span>(bu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的例子就是全局函数中对friend关键字的利用，就是把函数出去代码块的内容全部复制，然后在类中public作用域上面写上关键字frined然后再把复制内容粘贴上去就可以实现让全局函数访问类中的私有属性了。</p><h2 id="（2）类做友元"><a href="#（2）类做友元" class="headerlink" title="（2）类做友元"></a>（2）类做友元</h2><p>后面其他做友元的方式和全局函数做友元的方法差不多，下面提供类做友元的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 告诉编译器别着急报错，building类后面再写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goodguy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类内声明</span></span><br><span class="line">    <span class="built_in">Goodguy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Building *bu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类中将Goodguy这个类添加为一个友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Goodguy</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 利用初始化列表对类中的属性进行初始化</span></span><br><span class="line">    <span class="built_in">Building</span>() : <span class="built_in">sittingroom</span>(<span class="string">&quot;客厅&quot;</span>), <span class="built_in">bedroom</span>(<span class="string">&quot;卧室&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string sittingroom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外初始化</span></span><br><span class="line">Goodguy::<span class="built_in">Goodguy</span>() : <span class="built_in">bu</span>(<span class="keyword">new</span> Building) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Goodguy::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你的好基友正在访问你的&quot;</span> &lt;&lt; bu-&gt;sittingroom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你的好基友正在访问你的&quot;</span> &lt;&lt; bu-&gt;bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Goodguy gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码可能看不出来和全局函数做友元有什么差别，但是有一点几定要注意！！！</p><p>1、<strong>就是如果Building类在后面进行定义的话也就是做友元的那个类之后，一定要先进行声明！</strong></p><p>2、<strong>如果要通过前面类的成员访问后面类的成员一定要在后面类之后进行类内声明类外初始化！</strong></p><h2 id="（3）成员函数做友元"><a href="#（3）成员函数做友元" class="headerlink" title="（3）成员函数做友元"></a>（3）成员函数做友元</h2><p>如果我们想要类中其中一个成员函数做为友元的话方法类似，而且和类做友元一样是要注意那两点</p><p>其实对于类做友元只需要改一处地方就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//friend class Goodguy;</span></span><br><span class="line"><span class="comment">//改为</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Goodguy::visit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">洛希的六月份笔记内容</summary>
    
    
    
    <category term="C++" scheme="https://bg.luoxi.work/categories/C/"/>
    
    
    <category term="类和对象" scheme="https://bg.luoxi.work/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>对象特性</title>
    <link href="https://bg.luoxi.work/2023/02/08/2023/Feb/2/"/>
    <id>https://bg.luoxi.work/2023/02/08/2023/Feb/2/</id>
    <published>2023-02-08T14:00:00.000Z</published>
    <updated>2023-06-03T10:49:16.450Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="对象特性"><a href="#对象特性" class="headerlink" title="对象特性"></a>对象特性</h1><h3 id="（1）对象的初始化和清理"><a href="#（1）对象的初始化和清理" class="headerlink" title="（1）对象的初始化和清理"></a>（1）对象的初始化和清理</h3><p>对于对象的<code>初始化</code>和<code>清理</code>是十分重要的安全问题。</p><p>一个对象或者变量没有初始化状态，对其使用后果是未知的。</p><p>同样的使用完一个对象或者变量，没有及时清理掉，也会造成一定的安全问题。</p><p>C++利用了构造函数和析构函数可以解决上述的问题，这两个函数如果我们不调用编译器将会自动调用，如果<code>我们不提供构造和析构，编译器会提供的构造函数和析构函数是空实现</code>。</p><h3 id="（2）构造函数和析构函数"><a href="#（2）构造函数和析构函数" class="headerlink" title="（2）构造函数和析构函数"></a>（2）构造函数和析构函数</h3><p><strong>构造函数：</strong>主要作用在于创建对象时为对象的<code>成员属性赋值</code>，构造函数由编译器自动调用，无需手动调用。</p><p><strong>析构函数：</strong>主要作用在于对象<code>销毁前</code>系统自动调用，执行一些<code>清理工作</code>。</p><p><strong>构造函数语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名()&#123;&#125;</span><br></pre></td></tr></table></figure><p>1、构造函数，没有返回值也不写void</p><p>2、<code>函数名称与类名相同</code></p><p>3、<code>构造函数可以带参数</code>，因此<code>可以发生重载</code></p><p>4、程序在<code>调用对象</code>时会<code>自动调用构造</code>，无须手动调用，而且<code>只会调用一次</code>。</p><p><strong>析构函数语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~类名()&#123;&#125;</span><br></pre></td></tr></table></figure><p>1、析构函数，没有返回值也不写void</p><p>2、函数名称与类名相同，<code>在名称前能加上符号~</code></p><p>3、<code>析构函数不可以有参数</code>，因此<code>不可以发生重载</code></p><p>4、程序在<code>对象销毁</code>前会<code>自动调用析构</code>，无须手动调用而且只<code>会调用一次</code>。</p><p>比如以下的代码将展示构造函数和析构函数的共功能以及它们被调用的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="comment">// 对象实例化之后就会调用</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;person 的构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="comment">// 对象被销毁之后就会被调用</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的析构函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化一个对象</span></span><br><span class="line">    Person p;</span><br><span class="line">    <span class="comment">// 先让它不被释放</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上的代码输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302112037581.png" alt="image-20230211203705436"></p><p>如果我们不结束那个循环此时的话析构函数是无法被调用的。因为实例化的对象是在栈上的数据，函数不结束是不会被释放的。如果我们注释掉那个循环，此时析构函数就会被调用，如下所示。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302112040493.png" alt="image-20230211204028426"></p><h3 id="（3）构造函数的分类和调用"><a href="#（3）构造函数的分类和调用" class="headerlink" title="（3）构造函数的分类和调用"></a>（3）构造函数的分类和调用</h3><p><strong>两种分类方式：</strong></p><p>按参数分为：有参构造和无参构造</p><p>按类型分为：普通构造和拷贝构造</p><p><strong>三种调用方式：</strong></p><p>括号法</p><p>显示法</p><p>隐式转换法</p><p>以下代码来展示不同类型的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数的分类和调用</span></span><br><span class="line">    <span class="comment">// 分类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按参数分类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造(默认构造)</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的无参构造的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Peroson 的有参构造的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按类型分类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的构造函数的方式被称为普通构造。</span></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="comment">// 拷贝构造函数本体（引用）不能被修改（const）！</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将传入的人的身上的所有属性，拷贝到我身上。</span></span><br><span class="line">        age = p.age;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的拷贝函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Perosn 的析构函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 括号法</span></span><br><span class="line">    Person p1;     <span class="comment">// 默认构造函数的调用</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 有参函数的调用</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">// 拷贝构造函数调用</span></span><br><span class="line">    <span class="comment">// 注：调用默认构造函数时候，不要加()如Person p()，这样编译器会认为其为函数声明;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示法</span></span><br><span class="line">    Person p1;</span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); <span class="comment">// Person（10）此为匿名对象</span></span><br><span class="line">    Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名对象</span></span><br><span class="line">    <span class="comment">// 匿名对象的特点是在当前行执行完就会马上被释放，比如以下</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;abab!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 注：不要利用拷贝构造函数类初始化匿名对象</span></span><br><span class="line">    <span class="comment">// 编译器会认为此为对象的声明Person(p3) == Perosn p3;</span></span><br><span class="line">    <span class="built_in">Person</span>(p3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐式转换法</span></span><br><span class="line">    Person p4 = <span class="number">10</span>; <span class="comment">// 相当于写了Person p4的有参构造</span></span><br><span class="line">    Person p5 = p4; <span class="comment">// 相当于写了Perosn 的拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于调用的方法最推荐用的是括号法，这是最清晰以及最简洁的方法。</strong></p><h3 id="（4）拷贝构造函数的调用时机"><a href="#（4）拷贝构造函数的调用时机" class="headerlink" title="（4）拷贝构造函数的调用时机"></a>（4）拷贝构造函数的调用时机</h3><p>C++中拷贝构造函数的调用时机通常由三种情况</p><p>1、使用一个以及<code>创建完毕的对象来初始化一个对象</code></p><p>2、<code>值传递</code>的方式给函数参数传值</p><p>3、以<code>值方式返回局部对象</code></p><p>上面的三种情况将用以下代码来进行演示下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Person 的无参构造调用！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Person 的有参构造的调用!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Person 的析构函数的调用！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;p2的年龄:  &quot;</span>&lt;&lt;p2.age&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//值传递会创建一个副本代表被拷贝的那个对象，也属于复制的过程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(Person p)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">ReturnPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="comment">//返回的过程也是一一进行复制</span></span><br><span class="line">        cout&lt;&lt;(<span class="type">int</span>*)&amp;p1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建对象p来接收test03返回的对象</span></span><br><span class="line">    Person p = <span class="built_in">ReturnPerson</span>();</span><br><span class="line">    <span class="comment">//通过打印地址证明两个并不是同一个对象</span></span><br><span class="line">    cout&lt;&lt;(<span class="type">int</span>*)&amp;p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面三个测试案例，它们分别的输出结果如下所示</p><p><strong>test01:</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302112159397.png" alt="image-20230211215958318"></p><p><strong>test02:</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302112200604.png" alt="image-20230211220037537"></p><p><strong>test03:</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302112229781.png" alt="image-20230211222939715"></p><p>以上都为vscode的结果，肯定会有人好奇为什么test03没有调用拷贝构造函数，是因为有的编译器支持一种优化技术，叫做<code>RVO</code>（返回值优化技术）</p><p><code>返回值优化（Return Value Optimization，RVO）</code>是一种优化技术，其目的是在返回大量数据的函数中避免不必要的内存分配和数据复制。</p><p>然而，并不是所有编译器都支持返回值优化，或者<code>有时编译器也可能不会对某些函数进行返回值优化</code>。因此，在某些情况下，<code>在返回局部对象时仍然可能调用拷贝构造函数</code>。为了<code>确保可移植性</code>，最好<code>避免在函数中返回局部对象</code>，并在需要时显式地使用动态内存分配，以确保在所有情况下都能够正确地工作。</p><h3 id="（5）构造函数调用规则"><a href="#（5）构造函数调用规则" class="headerlink" title="（5）构造函数调用规则"></a>（5）构造函数调用规则</h3><p>默认情况下，C++编译器至少给一个类添加三个函数</p><p>1、默认构造（无参，函数体为空）</p><p>2、默认析构函数（无参，函数体为空）</p><p>3、默认拷贝构造函数，对属性进行值拷贝</p><p><strong>调用规则：</strong></p><p>1、如果用户定义有参构造函数，C++在不提供默认无参构造，但是会提供默认拷贝构造</p><p>2、如果用户定义拷贝构造函数，C++不会提供其他构造函数</p><p><strong>①创建类，C++至少会添加三个函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的无参构造调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的有参构造的调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的析构函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302112249918.png" alt="image-20230211224925818"></p><p>对于以上我们并未定义拷贝构造函数，但是编译器自动给我们提供了一个拷贝构造函数。</p><p><strong>②定义了有参构造，编译器不提供默认构造，但提供拷贝构造</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="comment">// Person()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;Person 的无参构造调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的有参构造的调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的拷贝构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = p.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的析构函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上的代码会出现以下的报错</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302112254490.png" alt="image-20230211225443440"></p><p>但是，此时是提供拷贝构造的，比如以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="comment">// Person()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;Person 的无参构造调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的有参构造的调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 拷贝构造</span></span><br><span class="line">    <span class="comment">// Person(const Person &amp;p)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;Person 的拷贝构造函数的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//     this-&gt;age = p.age;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的析构函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302112257885.png" alt="image-20230211225704805"></p><p><strong>③定义了拷贝构造函数，编译器不提供其他的普通构造函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="comment">// Person()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;Person 的无参构造调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 有参构造</span></span><br><span class="line">    <span class="comment">// Person(int age)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     this-&gt;age = age;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;Person 的有参构造的调用!&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的拷贝构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = p.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person 的析构函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会出现以下报错</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302112300976.png" alt="image-20230211230029924"></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302112300295.png" alt="image-20230211230047239"></p><p>通过以上的例子我们可以发现，实际有参构造，无参构造，拷贝构造有一种地位的感觉，如果定义了地位高的构造就不会提供低级构造。</p><h3 id="（6）深拷贝和浅拷贝"><a href="#（6）深拷贝和浅拷贝" class="headerlink" title="（6）深拷贝和浅拷贝"></a>（6）深拷贝和浅拷贝</h3><h4 id="①浅拷贝"><a href="#①浅拷贝" class="headerlink" title="①浅拷贝"></a>①浅拷贝</h4><p>一般<code>编译器会默认提供的拷贝操作</code>，也是简单的一种拷贝操作。</p><p>比如以下的代码就是编译器提供浅拷贝操作的一个案例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的默认构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        m_age = age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; p1.m_age &lt;&lt; endl;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是编译器默认提供了一个拷贝构造函数，将p1对象拷贝给了p2对象。输出结果如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302221940766.png" alt="image-20230222194017660"></p><p>但是如果我们想要把一个身高的数据开辟到堆区的话，如果我们继续利用浅拷贝会发生什么呢？我们来看下面的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的默认构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height)</span><br><span class="line">    &#123;</span><br><span class="line">        m_age = age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height); <span class="comment">// 在堆区开辟内存</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_height;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span> *m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道在堆区开辟内存之后，程序员应该手动将它释放，此时<code>析构函数</code>的作用就展现出来啦，就是<code>释放堆区开辟的内存</code>！所以我们也必须用到delete函数将堆区开辟的内存给释放掉，上面的代码究竟会出现什么情况呢？</p><p>很遗憾的告诉你，程序崩了<img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302221953591.png" alt="image-20230222195325360"></p><p>在vs2017里面，会出现这样的结果，当然其他编译器可能也会出现不一样的结果，但是还是以vs2017的这个结果为准，所以为什么会崩呢？请看下图</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302222006346.png" alt="image-20230222200608276"></p><p>此时我相信很多人都看出来问题了，就是重复释放的问题，在释放了第一次之后，此时的指针变成了一个<code>悬挂指针</code>，它所指向的内存空间为空，但是指针不为空，所以导致了重复释放。</p><p>解决以上的问题有以下的几种解决方法</p><ol><li>在释放指针所指向的内存之后，将指针赋值为NULL或nullptr，以避免指针悬挂问题。</li><li>禁止对象的浅拷贝，使用深拷贝或者移动语义来确保对象的生命周期内不会出现悬挂指针。</li><li>使用智能指针等RAII技术，来管理动态内存的分配和释放，从而避免手动管理内存带来的问题。</li></ol><p>此处演示下第二种深拷贝的方法</p><h4 id="②深拷贝"><a href="#②深拷贝" class="headerlink" title="②深拷贝"></a>②深拷贝</h4><p>深拷贝就是<code>在堆区重新申请一个内存空间</code>，将数据拷贝进去。</p><p>此时的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的默认构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个执行深拷贝的拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的拷贝构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_age = p.m_age;<span class="comment">//编译器默认执行的拷贝</span></span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);<span class="comment">//程序员自己定义的深拷贝操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height)</span><br><span class="line">&#123;</span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height); <span class="comment">// 在堆区开辟内存</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的有参构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="type">int</span> *m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码就在拷贝构造函数里面又开辟了堆区的内存，实现了深拷贝。输出结果正常如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302222018873.png" alt="image-20230222201850796"></p><p>此时的图解如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302222024004.png" alt="image-20230222202139225"></p><h3 id="（7）初始化列表"><a href="#（7）初始化列表" class="headerlink" title="（7）初始化列表"></a>（7）初始化列表</h3><p>C++提供了初始化列表的语法，用来初始化属性</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时值已经定死，不太灵活 </span></span><br><span class="line"><span class="number">1</span>、 构造函数():属性<span class="number">1</span>(值<span class="number">1</span>),属性<span class="number">2</span>(值<span class="number">2</span>)...属性<span class="built_in">n</span>(值n)&#123;&#125;</span><br><span class="line"><span class="comment">//此时可以灵活的赋值，相当于之前有参构造的写法</span></span><br><span class="line"><span class="number">2</span>、 构造函数(a1,a2,...,an):属性<span class="number">1</span>(a1),属性<span class="number">2</span>(a2)...属性<span class="built_in">n</span>(an)&#123;&#125;</span><br></pre></td></tr></table></figure><p>下面将用代码来演示下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用第一种方法进行初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person1</span>() : <span class="built_in">name</span>(<span class="string">&quot;luoxi&quot;</span>), <span class="built_in">age</span>(<span class="number">18</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintfPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name :&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age :&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用第二种方式进行初始化 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person2</span>(string a1, <span class="type">int</span> a2) : <span class="built_in">name</span>(a1), <span class="built_in">age</span>(a2) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintfPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name :&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age :&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person1 p1;</span><br><span class="line">    p1.<span class="built_in">PrintfPerson</span>();</span><br><span class="line">    <span class="function">Person2 <span class="title">p2</span><span class="params">(<span class="string">&quot;luoxi2&quot;</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">    p2.<span class="built_in">PrintfPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为上例代码输出的结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202303111547724.png" alt="image-20230311071741639"></p><h3 id="（8）类对象作为类成员"><a href="#（8）类对象作为类成员" class="headerlink" title="（8）类对象作为类成员"></a>（8）类对象作为类成员</h3><p>C++类中的成员可以是另一个类的对象，我们称该成员为<code>对象成员</code></p><p>它的形式通常如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">A a;<span class="comment">//在B类中有A类的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于上面的例子可以看到B类中有A类的对象，被称为对象成员</p><p>那么是先有A对象还是先有B对象呢？或者说A和B的构造和析构的顺序是谁先谁后呢？</p><p>下面将用代码来进行演示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eye</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Eye</span>(string a1) : <span class="built_in">eyesname</span>(a1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Eye构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Eye</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Eye析构函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string eyesname;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a1, string a2) : <span class="built_in">age</span>(a1), <span class="built_in">eyes</span>(a2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person构造函数的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    Eye eyes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">18</span>, <span class="string">&quot;Blue eyes&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄: &quot;</span> &lt;&lt; p.age &lt;&lt; <span class="string">&quot; 眼睛: &quot;</span> &lt;&lt; p.eyes.eyesname &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面代码的输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202303120201982.png" alt="image-20230312020145805"></p><p>可以看出来，是必须现有眼睛这个对象才能有人，其实这也不难想，如果没有了眼睛该如何构造出来一个人呢？同理后面的析构也一样，只有人死去了，眼睛才会慢慢腐烂而去。</p><h3 id="（9）静态成员"><a href="#（9）静态成员" class="headerlink" title="（9）静态成员"></a>（9）静态成员</h3><p>静态成员就是在成员变量和成员函数中加上关键字static，称为<code>静态成员</code></p><p>静态成员分类有以下两点：<br>1、静态成员变量</p><p>（1）所有对象共享同一份数据</p><p>（2）在编译阶段分配内存</p><p>（3）<strong>类内声明，类外初始化</strong></p><p>2、静态成员函数</p><p>（1）所有成员共享同一个函数</p><p>（2）静态成员只能访问静态成员变量</p><h4 id="①静态成员变量"><a href="#①静态成员变量" class="headerlink" title="①静态成员变量"></a>①静态成员变量</h4><p>首先是先给出静态成员变量相关的示例代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">    <span class="comment">// 静态成员也有访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内声明，类外进行初始化(这一步必须执行！！！)</span></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">114514</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">520</span>;</span><br><span class="line"><span class="comment">// 静态成员变量的相关定义以及赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;========test01========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Person p1;</span><br><span class="line">    cout &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line">    Person p2;</span><br><span class="line">    <span class="comment">// 其他对象也可以对这个变量进行改值，可以影响到其他成员这个属性的值</span></span><br><span class="line">    p2.m_A = <span class="number">1919810</span>;</span><br><span class="line">    cout &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态成员变量的相关访问操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;========test02========&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 对象访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象进行访问:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 无法访问!!!</span></span><br><span class="line">    <span class="comment">//  cout &lt;&lt; p.m_B &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//  类名访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名进行访问:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 无法访问!!!</span></span><br><span class="line">    <span class="comment">//  cout &lt;&lt; Person::m_B &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码的输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202303122304800.png" alt="image-20230312230416687"></p><p><strong>注：对于上面的代码，以及前面的标注，记得在定义静态成员变量的时候一定一定要在类外进行初始化！！！</strong></p><p>对于静态成员也是有访问权限，如下图：<img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202303122303190.png" alt="image-20230312230347990"></p><h4 id="②静态成员函数"><a href="#②静态成员函数" class="headerlink" title="②静态成员函数"></a>②静态成员函数</h4><p>静态成员函数大部分其实都跟静态成员变量很相似，请看如下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态成员函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 静态成员函数只能访问静态成员变量</span></span><br><span class="line">        m_A = <span class="number">1919810</span>;</span><br><span class="line">        <span class="comment">// 静态成员函数不能访问非静态成员变量</span></span><br><span class="line">        <span class="comment">// 原因是因为非静态成员变量是对象特定的属性，不属于公共部分，所以导致静态成员函数无法进行确定此属性是哪个对象的，所以无法进行访问</span></span><br><span class="line">        <span class="comment">// m_B = 11415l;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;static void func 的调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">    <span class="comment">// 非静态成员变量</span></span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 静态成员函数也有访问权限</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 一定要类外进行初始化!!!</span></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">114514</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试访问的方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象来进行访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">func1</span>();</span><br><span class="line">    <span class="comment">// p.func2();</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名来进行访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Person::<span class="built_in">func1</span>();</span><br><span class="line">    <span class="comment">// Person::func2();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上的代码的输出结果如下所示:</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202303122358967.png" alt="image-20230312235836775"></p><p>对于上面的代码有关静态成员函数不能访问非静态成员变量的报错如下：</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202303130000797.png" alt="image-20230313000000728"></p><p><code>原因是因为非静态成员变量是对象特定的属性，不属于公共部分，所以导致静态成员函数无法进行确定此属性是哪个对象的，所以无法进行访问</code></p><p>还有静态成员函数有访问权限的地方和静态成员变量类似。</p><h4 id="③成员变量和成员函数的分开存储"><a href="#③成员变量和成员函数的分开存储" class="headerlink" title="③成员变量和成员函数的分开存储"></a>③成员变量和成员函数的分开存储</h4><p>在C++中，类内的成员函数和成员变量是分开存储的。</p><p>请看如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b; <span class="comment">// 类内声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person2::b = <span class="number">114514</span>; <span class="comment">// 类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空对象占一个字节</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person1 p1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof of p1 = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非空对象中只有成员变量占内存空间，成员函数和静态成员都不占</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person2 p2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof of p2 = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的两个test，输出结果如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202304120058578.png" alt="image-20230412005841006"></p><p>对于上面的代码，肯定会有人很好奇为什么空对象会占一个字节的空间？对于空对象为什么会占一个字节的空间，请看以下的解释。</p><p>在 C++ 等编程语言中，空对象通常会占据一个字节的内存空间。这是因为，在使用一个类或结构体定义的变量时，编译器需要知道该变量所占据的内存空间大小，以便<code>正确地计算内存地址等信息</code>。而如果不为空对象分配任何内存空间，则在<code>使用 sizeof 运算符等操作时可能会得到意外的结果</code>。</p><p>另外，一个字节的内存空间相对较小，并不会对程序的性能和内存占用产生明显的影响。因此，<code>为了避免出现未知的问题，一般会将空对象分配至少一个字节的内存空间。</code></p><p>其实总的来说这一个字节的空间是为了防止操作出现的一些问题。</p><h3 id="（10）this指针的用途"><a href="#（10）this指针的用途" class="headerlink" title="（10）this指针的用途"></a>（10）this指针的用途</h3><p>在C++中，成员函数和成员变量是分开存储的，每一个非静态的成员函数只会诞生一个函数的实例，也就是说多个同类型的对象只会共用这一个函数实例。</p><p>对于以上的问题我们应该如何去进行区分呢？此时就要用到C+<br>+特殊的对象指针–this指针，来解决上面的相关问题，this指针指向被调用成员函数所属的对象。</p><p><strong>注意：</strong></p><p>1、this指针算隐含在每一个<code>静态成员函数</code>内的一种指针</p><p>2、this指针不需要定义，直接使用</p><p><strong>用途：</strong></p><p>1、当<code>形参和成员变量同名</code>时，可用this指针来区分。</p><p>2、可在类的非静态成员函数中<code>返回对象本身</code></p><p><strong>用途一、</strong></p><p>对于用途一，先举个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//让同名的形参给对象的属性进行赋值操作</span></span><br><span class="line">    age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1的年龄：&quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上的代码就是通过在类中写一个有参构造，然后在实例化对象的时候进行初始化操作，输出结果如下。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202305191714105.png" alt="image-20230519171416466"></p><p>通过输出结果我们可以看到此时的值不是我们所预期的结果，就是因为存在<code>同名的变量</code>而导致的。因为此时编译器就分不清左右两个age哪个才是成员属性哪个是形参变量。正确应该更改有参构造里面的内容如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//age = age</span></span><br><span class="line"><span class="comment">//this指针指向被调用成员函数所属的对象</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age</span><br></pre></td></tr></table></figure><p>对于上面this-&gt;age = age的注释，我们可以理解哪个对象调用了类中的函数，this指针就指向哪个对象，比如你p1调用啦有参构造函数，那么this指针就指向p1对象，同理如果你是p2对象也是一样的。</p><p><strong>用途二、</strong></p><p>如果我们想要实现两个类中的成员属性进行相加的操作，我们应该如何去实现呢？一般人可能第一想到在类中写一个成员函数去实现此功能，比如以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实现相加的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PersonAgeAdd</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">45</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">PersonAgeAdd</span>(p2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age of p1 = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这个代码还是存在一定的缺陷的，比如我们想要去完成一个累加的操作，就比如将p1的年龄进行重复加上p2的年龄，此时应该怎么办呢？</p><p>下面提供我的几种思路</p><p><strong>思路一：利用循环进行解决重复性的问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">45</span>)</span></span>;</span><br><span class="line">    <span class="comment">// p1.PersonAgeAdd(p2);</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i--)</span><br><span class="line">    &#123;</span><br><span class="line">        p1.<span class="built_in">PersonAgeAdd</span>(p2);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age of p1 = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的思路就是修改test01里面的内容，<code>将里面对于p1对象的年龄相加的成员函数的调用次数进行循环实现自己想要的次数</code>。</p><p><strong>思路二：理解用途二，巧用this指针</strong></p><p>对于思路二，可能会有人存在一个错误的想法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">45</span>)</span></span>;</span><br><span class="line">    <span class="comment">// p1.PersonAgeAdd(p2);</span></span><br><span class="line">    p1.<span class="built_in">PersonAgeAdd</span>(p2).<span class="built_in">PersonAgeAdd</span>(p2).<span class="built_in">PersonAgeAdd</span>(p2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age of p1 = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个错误是个特别明显的错误，因为PersonAgeAdd这个成员函数是个void类型的函数，所以它没有返回值，所以这样重复调用毫无意义。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202305191734945.png" alt="image-20230519173446838"></p><p>所以，根据返回的类型来想，如果PersonAgeAdd这个成员函数的类型是Person类型呢？比如我们看一下的修改方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个Person类型的成员函数</span></span><br><span class="line">    <span class="function">Person <span class="title">PersonAgeAdd</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="comment">//返回调用该函数的对象本身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样改编译器就不会显示报错了，但是这样改真的是正确的吗？我们来看下这样的修改的输出结果将会怎么样。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202305191739725.png" alt="image-20230519173929084"></p><p>我们会看到，这样的代码不能实现该有的功能！这是为什么呢？</p><p>对于以上的疑问我们还是要想想成员函数的类型返回的真的是对象的本身吗？还是一直返回的是它的“替身”。</p><p>我们利用一个代码来帮助理解下为什么会这样吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个Person类型的成员函数</span></span><br><span class="line">    <span class="function">Person <span class="title">PersonAgeAdd</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//注意是先进行加的操作，所以第一次经历过这个操作才有了p1年龄等于56的结果，后面都是新的对象</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="comment">// 返回调用该函数的对象本身</span></span><br><span class="line">        cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">45</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;p1);</span><br><span class="line">    p1.<span class="built_in">PersonAgeAdd</span>(p2).<span class="built_in">PersonAgeAdd</span>(p2).<span class="built_in">PersonAgeAdd</span>(p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age of p1 = &quot;</span> &lt;&lt; (p1.age) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上的代码，我们通过监视地址来看每次到底是不是p1本身，输出结果如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202305191822998.png" alt="image-20230519182226507"></p><p>我们发现除了第一次，<code>每一次经过返回之后地址就发生了更改</code>，这就是导致了不能累加的原因，利用了Person的类型，每次返回都会导致创建一个新的对象进行储存改变后新的对象。</p><p>通过这点我们该如何进行应对呢？此时应该利用引用的知识了。</p><p>因为引用作为函数类型的话此时返回的就是对象的本身，也就是每次的地址都会相同。修改如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个Person&amp;类型的成员函数</span></span><br><span class="line">    <span class="function">Person &amp;<span class="title">PersonAgeAdd</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">        <span class="comment">// 返回调用该函数的对象本身</span></span><br><span class="line">        cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后的输出结果也可以发现每次的地址都是一样的</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202305191827365.png" alt="image-20230519182741950"></p><h3 id="（11）空指针调用成员函数"><a href="#（11）空指针调用成员函数" class="headerlink" title="（11）空指针调用成员函数"></a>（11）空指针调用成员函数</h3><p>对于C++中其实空指针也是可以调用成员函数的，其中的关键在于是否运用到了<code>this指针</code></p><p>比如以下的案例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func 函数的调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//使用了成员属性age，默认为this-&gt; age</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age = <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person *p1 = <span class="literal">NULL</span>;</span><br><span class="line">    p1-&gt;<span class="built_in">func</span>();</span><br><span class="line">    p1-&gt;<span class="built_in">ShowAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在test函数中就用空指针p1调用运用了this指针的ShowAge成员函数，这会导致未定义的行为从而使得程序崩溃，但是如果调用未运用到this指针的func就不会出现这个问题。</p><h3 id="（12）const关键字在类和对象的运用"><a href="#（12）const关键字在类和对象的运用" class="headerlink" title="（12）const关键字在类和对象的运用"></a>（12）const关键字在类和对象的运用</h3><p>C++中在类和对象中也有对于const关键字的相关运用，对此运用分为两方面，一个是对<code>成员函数的修饰</code>，另外一个是对<code>成员对象的修饰</code>。</p><h4 id="①const修饰成员函数"><a href="#①const修饰成员函数" class="headerlink" title="①const修饰成员函数"></a>①const修饰成员函数</h4><p>通常情况下在<code>成员函数后加上const关键字</code>的函数我们一般成为<code>常函数</code></p><p>对于常函数有以下几个知识点：<br>1、常函数内不可以修改成员属性</p><p>2、成员属性声明时加关键字mutable后，在常函数中依然可以修改</p><p>对于上面几点我们来举以下的几个例子 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//此时这个地方就会报错</span></span><br><span class="line">        <span class="comment">//报错信息为表达式必须是可修改的左值</span></span><br><span class="line">        <span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于上面的例子就是对于知识点1的相关内容，我们可以发现如果在成员函数后面加上const修饰之后就会导致成员函数内无法修改成员属性的值，这个的原因在于<code>this指针的本质</code>。</p><p>this指针的本质是一个指针常量，指针的指向是不可修改的。this指针在C++中的声明如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无法修改指向 </span></span><br><span class="line">(类名) * <span class="type">const</span> <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p>因为const在<code>(类名)  *</code>后面，所以我们无法修改this指针的指向。如果我们想不修改它指向的值该怎么办呢？那就应该在(类名)前加上一个const。如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//既无法修改指向，也无法修改指向的值</span></span><br><span class="line"><span class="built_in">const</span> (类名) * <span class="type">const</span> <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p>通过这一点就可以知道为什么在类中的成员函数无法修改对应成员属性的值了，其实<code>在函数后面加上const就同等于在每个你要在里面修改的属性中加上了一个const</code>。</p><p>但是我们如果偏偏要修改那该怎么办呢？这就涉及到知识点2的内容了，此时就需要用到<code>mutable</code>关键字了。即在想要在常函数修改的成员属性的声明前加上mutable就行，比如就上面举例的那个类修改如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//此时这个地方就不会报错</span></span><br><span class="line">        <span class="comment">//因为mutable关键字发挥的作用</span></span><br><span class="line">        <span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">mutable</span> <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="②const修饰对象"><a href="#②const修饰对象" class="headerlink" title="②const修饰对象"></a>②const修饰对象</h4><p>const修饰的对象的话我们一般称作为<code>常对象</code>。</p><p>常对象的知识点有如下几点</p><p>1、常对象不可以修改对象对应的属性的值，除非属性声明前有mutable关键字。</p><p>2、常对象只能调用常函数</p><p>我们可以发现以上的知识点和常函数有一些十分的相似，对于以上的知识点我们可以举以下的几个例子。</p><p>比如我们先声明一个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们开始实例化一个常对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> Person p;</span><br><span class="line">    <span class="comment">//这里不会报错，因为属性age被mutable关键字修饰的特殊属性</span></span><br><span class="line">    p.age = <span class="number">18</span>;</span><br><span class="line">    <span class="comment">//这里会报错，因为常对象无法修改对应属性的值</span></span><br><span class="line">    p.weight = <span class="number">60</span>;</span><br><span class="line">    <span class="comment">//这里不会报错，因为常对象只能调用常函数</span></span><br><span class="line">    p.<span class="built_in">ShowPerson</span>();</span><br><span class="line">    <span class="comment">//这里会报错，因为常对象无法调用非常函数</span></span><br><span class="line">    p.<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第2个知识点为什么常对象无法调用类中的普通的成员函数，是因为<code>普通的成员函数我们知道是可以进行修改类中的属性的</code>。而<code>常对象是不能进行修改对应的属性</code>，所以这点与其违背，所以常对象无法调用普通的成员函数。</p>]]></content>
    
    
    <summary type="html">洛希的二月份笔记内容</summary>
    
    
    
    <category term="C++" scheme="https://bg.luoxi.work/categories/C/"/>
    
    
    <category term="类和对象" scheme="https://bg.luoxi.work/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>封装</title>
    <link href="https://bg.luoxi.work/2023/02/06/2023/Feb/1/"/>
    <id>https://bg.luoxi.work/2023/02/06/2023/Feb/1/</id>
    <published>2023-02-06T14:00:00.000Z</published>
    <updated>2023-05-30T05:54:52.002Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="①封装的意义"><a href="#①封装的意义" class="headerlink" title="①封装的意义"></a>①封装的意义</h2><p>1.将属性和行为作为一个整体，表现生活中的事物。</p><p>2.将属性和行为加以<code>权限</code>进行控制</p><h3 id="（1）封装意义一"><a href="#（1）封装意义一" class="headerlink" title="（1）封装意义一"></a>（1）封装意义一</h3><p>设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line">访问权限:</span><br><span class="line">属性（行为）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><p>设计一个<code>圆类</code>，求圆的周长。</p><p>对于上面的案例可以知道要我们设计一个<code>类是圆类</code>，它的类之间执行一个<code>行为是求圆的周长</code>，然后对于执行这个行为必不可少的<code>属性是圆的半径</code>。</p><p>所以关于该案例的代码可以这样写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局区的变量PI表示圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计一个圆类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 访问权限是public</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 属性(定义整形变量r为半径)</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="comment">// 行为(计算周长)</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * PI * r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 通过圆类创建具体的圆(实例化对象)</span></span><br><span class="line">Circle c1;</span><br><span class="line"><span class="comment">// 给该对象的属性进行赋值</span></span><br><span class="line">c1.r = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 执行该对象的行为获取该周长</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;圆的周长为: &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）封装意义二"><a href="#（2）封装意义二" class="headerlink" title="（2）封装意义二"></a>（2）封装意义二</h3><p>类在设计是，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有以下三种：</p><p><strong>1、public（公共权限）</strong></p><p>类内可以访问，类外不能访问</p><p><strong>2、protected（保护权限）</strong></p><p>类内可以访问，类外不可以访问</p><p><strong>3、private（私有权限）</strong></p><p>类内可以访问，类外不可以访问</p><p><strong>注：</strong>虽然看起来保护权限和私有权限很像，但是在后面继承之中它们之间是存在很大的区比。比如继承相当于是父子关系，父亲类内的私有内容被儿子继承之后是无法进行访问的。</p><p>其实我们可能可以发现C++中的类其实和结构体有很大的相似之处，这确实如此！但是它们最大的<code>区别</code>就是在它们的<code>默认访问权限不同</code>。</p><p>比如以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//默认权限为公共权限</span></span><br><span class="line"><span class="type">int</span> t1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//默认权限为私有权限</span></span><br><span class="line"><span class="type">int</span> t2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个结构体变量</span></span><br><span class="line">Test1 st;</span><br><span class="line">Test2 ct;</span><br><span class="line">st.t1 = <span class="number">114514</span>;</span><br><span class="line">ct.t2 = <span class="number">114514</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不注释掉第24行代码将会发生以下的报错信息</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302080133738.png" alt="image-20230208013320611"></p><p>意思就是说无法访问到在类内私有权限的内容，所以由上可知，class创建的一个类默认的访问权限为<code>private</code>。</p><h2 id="②权限的重要作用"><a href="#②权限的重要作用" class="headerlink" title="②权限的重要作用"></a>②权限的重要作用</h2><p>通过上面的描述我们可以知道在类中一共有三种类型的权限，但是它们都有什么重要的作用呢？以下为私有权限的作用。</p><p>对于私有权限，我们可以将所有成员的属性设置为私有，它有以下几个优点。</p><p>1、将所有成员属性设置为私有，可以<code>自己控制读写权限</code>。</p><p>2、对于写权限 ，我们可以<code>检测数据的有效性</code>。</p><p>比如以下的代码，将展现其优点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计一个类代表一个人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 设计接口去访问私有权限的内容</span></span><br><span class="line"><span class="comment">// 写姓名（设置姓名）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Setname</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读姓名(获取姓名)</span></span><br><span class="line"><span class="function">string <span class="title">Getname</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 调用该函数之后就返回改姓名的字符串</span></span><br><span class="line"><span class="keyword">return</span> p_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读年龄(获取年龄)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Getage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写情人(设置情人)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Setlover</span><span class="params">(string lover)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p_lover = lover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 该人的姓名(类外可读可写)</span></span><br><span class="line">string p_name;</span><br><span class="line"><span class="comment">// 该人的年龄(类外只读)</span></span><br><span class="line"><span class="type">int</span> p_age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">// 该人的情人（类外只写）</span></span><br><span class="line">string p_lover;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 实例化一个对象</span></span><br><span class="line">Person p;</span><br><span class="line"><span class="comment">// 通过以上成员函数提供的接口进行访问私有权限的内容</span></span><br><span class="line"><span class="comment">// 通过成员函数Setname接口写入姓名</span></span><br><span class="line">p.<span class="built_in">Setname</span>(<span class="string">&quot;luoxi&quot;</span>);</span><br><span class="line"><span class="comment">// 通过成员函数Getname接口读取姓名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p.<span class="built_in">Getname</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 通过成员函数Getage接口读取年龄</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄：&quot;</span> &lt;&lt; p.<span class="built_in">Getage</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 通过成员函数Setlover接口写入情人</span></span><br><span class="line">p.<span class="built_in">Setlover</span>(<span class="string">&quot;纳西妲&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302080158964.png" alt="image-20230208015832898"></p><p>可以看出来输出的结果都是提供了可读接口的成员属性</p><p>这样写可以很好的展现出代码的自由度以及程序员可以更加灵活的运用类中的成员属性。</p><h2 id="③相关案例"><a href="#③相关案例" class="headerlink" title="③相关案例"></a>③相关案例</h2><h3 id="（1）案例一：设计立方体类"><a href="#（1）案例一：设计立方体类" class="headerlink" title="（1）案例一：设计立方体类"></a>（1）案例一：设计立方体类</h3><p><strong>题目：</strong></p><p>设计立方体类（Cube）</p><p>求出立方体的面积和体积</p><p>分别用全局函数和成员函数判断两个立方体是否相等</p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计立方体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cube</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 提供接口给私有属性赋值</span></span><br><span class="line"><span class="comment">// 设置长，宽，高</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetCube</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span> wide, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">c_length = length;</span><br><span class="line">c_wide = wide;</span><br><span class="line">c_height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别获取长宽高</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Getlength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c_length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Getwide</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c_wide;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Getheight</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c_height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义成员行为求面积或体积</span></span><br><span class="line"><span class="comment">// 计算面积的成员行为</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CubeS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> * c_length * c_wide + <span class="number">2</span> * c_length * c_height + <span class="number">2</span> * c_wide * c_height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算体积的成员行为</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CubeV</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c_length * c_wide * c_height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用成员函数来判断C1和C2立方体是否相等</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IssameCube</span><span class="params">(Cube &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (c_length == c.c_length &amp;&amp; c_wide == c.c_wide &amp;&amp; c_height == c.c_height)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 定义长这个成员属性</span></span><br><span class="line"><span class="type">int</span> c_length;</span><br><span class="line"><span class="comment">// 定义宽这个成员属性</span></span><br><span class="line"><span class="type">int</span> c_wide;</span><br><span class="line"><span class="comment">// 定义高这个成员属性</span></span><br><span class="line"><span class="type">int</span> c_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用全局函数判断两个立方体是否相等</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IssameCube2</span><span class="params">(Cube &amp;c1, Cube &amp;c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (c1.<span class="built_in">Getlength</span>() == c2.<span class="built_in">Getlength</span>() &amp;&amp; c1.<span class="built_in">Getwide</span>() == c2.<span class="built_in">Getwide</span>() &amp;&amp; c1.<span class="built_in">Getheight</span>() == c2.<span class="built_in">Getheight</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 实例化两个对象</span></span><br><span class="line">Cube c1, c2;</span><br><span class="line">c1.<span class="built_in">SetCube</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C1立方体的表面积为：&quot;</span> &lt;&lt; c1.<span class="built_in">CubeS</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C1立方体的体积为：&quot;</span> &lt;&lt; c1.<span class="built_in">CubeV</span>() &lt;&lt; endl;</span><br><span class="line">c2.<span class="built_in">SetCube</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 利用成员函数判断立方体C1和C2是否相等</span></span><br><span class="line"><span class="comment">// 定义布尔类型的ret取接收成员行为下的返回值</span></span><br><span class="line"><span class="type">bool</span> ret = c1.<span class="built_in">IssameCube</span>(c2);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C1和C2立方体相同！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C1和C2立方体不相同！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用全局函数判断立方体C1和C2是否相等</span></span><br><span class="line"><span class="type">bool</span> ret2 = <span class="built_in">IssameCube2</span>(c1, c2);</span><br><span class="line"><span class="keyword">if</span> (ret2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C1和C2立方体相同！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C1和C2立方体不相同！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）案例二：点和圆的关系"><a href="#（2）案例二：点和圆的关系" class="headerlink" title="（2）案例二：点和圆的关系"></a>（2）案例二：点和圆的关系</h3><p>设计一个圆形类（circle），和一个点类（point），计算点和圆的位置关系。</p><p>对于这个案例，可能会存在一些地方容易出错，因为对于圆这个类，它里面还包含了一个点类，所以我们应该先定义点类在定义圆类，或者在圆类声明点这个类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置x,y坐标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetCoord</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this指针是指向自身类的指针</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取x坐标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetcoordX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取y坐标</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetcoordY</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义xy坐标</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取圆心</span></span><br><span class="line">    <span class="comment">// 如果后续需要对改点进行修改坐标必须返回引用的类型，这样才能是点本身。</span></span><br><span class="line">    <span class="function">Point &amp;<span class="title">Getcenterpoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> centerpoint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置半径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Setr</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取半径</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Getr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义圆心</span></span><br><span class="line">    <span class="comment">// 在类中可以将其他类作为一个成员</span></span><br><span class="line">    Point centerpoint;</span><br><span class="line">    <span class="comment">// 定义半径</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数判断圆和直线的位置关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postion</span><span class="params">(Circle &amp;c, Point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">pow</span>(c.<span class="built_in">Getcenterpoint</span>().<span class="built_in">GetcoordX</span>() - p.<span class="built_in">GetcoordX</span>(), <span class="number">2</span>) + <span class="built_in">pow</span>(c.<span class="built_in">Getcenterpoint</span>().<span class="built_in">GetcoordY</span>() - p.<span class="built_in">GetcoordY</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="built_in">pow</span>(c.<span class="built_in">Getr</span>(), <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆上！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (length &lt; <span class="built_in">pow</span>(c.<span class="built_in">Getr</span>(), <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆内！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆外&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分别实例化一个点和一个圆</span></span><br><span class="line">    Circle c1;</span><br><span class="line">    Point p1;</span><br><span class="line">    <span class="comment">// 分别给对应的属性进行赋值</span></span><br><span class="line">    c1.<span class="built_in">Getcenterpoint</span>().<span class="built_in">SetCoord</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    c1.<span class="built_in">Setr</span>(<span class="number">2</span>);</span><br><span class="line">    p1.<span class="built_in">SetCoord</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 调用函数Postion来判断点和圆的位置关系</span></span><br><span class="line">    <span class="built_in">Postion</span>(c1, p1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>该代码有一个需要特别注意的点，比如第39行为什么返回类型是<code>引用</code>的方式，是因为这样返回的是本身的指针，<code>因为引用本身是一种常量指针，如果返回的是点类的话，返回的圆心并不是圆心本身，而是一个被一一复制的数据</code>，所以在后面的调用中很有可能会发生错误！！！</p><p>对于以上的代码的输出结果是：<br><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202302081726539.png" alt="image-20230208172628409"></p><p>可以发现是符合预期的，根据所设置的点和圆心以及半径来说</p><p>其实对于这种类比较多的还有其他的写法，比如如下所示</p><p>编写Point.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处编写声明</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetCoord</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetcoordX</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetcoordY</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义xy坐标</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编写Circle.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 引用头文件Point.h,因为Circle类中含有点类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Point.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Point &amp;<span class="title">Getcenterpoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Setr</span><span class="params">(<span class="type">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Getr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point centerpoint;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编写Circle.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Circle.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Point &amp;<span class="title">Circle::Getcenterpoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> centerpoint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置半径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Setr</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;r = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取半径</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Circle::Getr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写Point.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Point.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处编写实现</span></span><br><span class="line"><span class="comment">// 需要加Point::即指明作用域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::SetCoord</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// this指针是指向自身类的指针</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取x坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::GetcoordX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取y坐标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Point::GetcoordY</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过编写了以上的相关文件之后，对于主文件里面的代码就会变得十分简洁啦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Circle.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Point.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数判断圆和直线的位置关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Postion</span><span class="params">(Circle &amp;c, Point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">pow</span>(c.<span class="built_in">Getcenterpoint</span>().<span class="built_in">GetcoordX</span>() - p.<span class="built_in">GetcoordX</span>(), <span class="number">2</span>) + <span class="built_in">pow</span>(c.<span class="built_in">Getcenterpoint</span>().<span class="built_in">GetcoordY</span>() - p.<span class="built_in">GetcoordY</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="built_in">pow</span>(c.<span class="built_in">Getr</span>(), <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆上！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (length &lt; <span class="built_in">pow</span>(c.<span class="built_in">Getr</span>(), <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆内！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆外&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分别实例化一个点和一个圆</span></span><br><span class="line">    Circle c1;</span><br><span class="line">    Point p1;</span><br><span class="line">    <span class="comment">// 分别给对应的属性进行赋值</span></span><br><span class="line">    c1.<span class="built_in">Getcenterpoint</span>().<span class="built_in">SetCoord</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    c1.<span class="built_in">Setr</span>(<span class="number">2</span>);</span><br><span class="line">    p1.<span class="built_in">SetCoord</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 调用函数Postion来判断点和圆的位置关系</span></span><br><span class="line">    <span class="built_in">Postion</span>(c1, p1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">洛希的二月份笔记内容</summary>
    
    
    
    <category term="C++" scheme="https://bg.luoxi.work/categories/C/"/>
    
    
    <category term="类和对象" scheme="https://bg.luoxi.work/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>类和对象</title>
    <link href="https://bg.luoxi.work/2023/01/31/2023/Mon/13/"/>
    <id>https://bg.luoxi.work/2023/01/31/2023/Mon/13/</id>
    <published>2023-01-31T12:00:00.000Z</published>
    <updated>2023-02-06T17:51:33.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="①三大特性"><a href="#①三大特性" class="headerlink" title="①三大特性"></a>①三大特性</h2><p>C++面向对象的三大特性为：<code>封装、继承、多态</code></p><h2 id="②属性和行为"><a href="#②属性和行为" class="headerlink" title="②属性和行为"></a>②属性和行为</h2><p>C++认为万事万物都皆为对象，对象上有其属性和行为</p><p><strong>例如：</strong></p><p>人可以作为对象，是属于人这个类，属性有姓名、年龄、身高等，行为有走，跑，吃饭等。</p><h2 id="③成员"><a href="#③成员" class="headerlink" title="③成员"></a>③成员</h2><p><strong>类中的属性和行为都可以被称为成员</strong>。比如属性和行为都有以下的几个“绰号”。</p><p><strong>属性：</strong>成员属性、成员变量</p><p><strong>行为：</strong>成员函数、成员方法</p>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="C++" scheme="https://bg.luoxi.work/categories/C/"/>
    
    
    <category term="类和对象" scheme="https://bg.luoxi.work/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>函数提高</title>
    <link href="https://bg.luoxi.work/2023/01/31/2023/Mon/12/"/>
    <id>https://bg.luoxi.work/2023/01/31/2023/Mon/12/</id>
    <published>2023-01-31T08:00:00.000Z</published>
    <updated>2023-01-30T16:57:46.904Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h1><h2 id="①函数默认参数"><a href="#①函数默认参数" class="headerlink" title="①函数默认参数"></a>①函数默认参数</h2><p>在C++中，<code>函数形参列表中的形参是可以有默认值的</code></p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(参数 = 默认值)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种形式可以给程序员提供很大的自由度，比如以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数默认参数 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>) &lt;&lt; endl;<span class="comment">//给此时为被赋默认值的a进行赋值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如以上的代码给了b还有c默认值，而a没有，此时函数调用的时候只需要给a进行赋值，此时的输出结果如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301302226317.png" alt="image-20230130222629235"></p><p>那给了默认值的b还有c是否可以进行改值呢？答案是可以的，比如以下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数默认参数 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c = <span class="number">3</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; func(<span class="number">1</span>,<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//给此时为被赋默认值的a进行赋值,再给b赋值为3</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301302229999.png" alt="image-20230130222921924"></p><p>通过以上的例子我们可以总结如下</p><p><code>如果我们自己传入数据，就用自己的数据，如果没有，那么用默认值</code></p><p>但是，还是有些我们应该注意到以下的几点。</p><p>1、如果<code>某个位置已经有了默认参数</code>，那么从<code>这个位置往后</code>，<code>从左到右都必须有默认值</code>。</p><p>比如会出现下图的报错信息</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301302234439.png" alt="image-20230130223426374"></p><p>2、如果函数<code>声明有了默认参数</code>，函数<code>实现就不能有默认参数了</code> 。</p><p>比如以下例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明和实现只能有一个有默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">114514</span>, <span class="type">int</span> b = <span class="number">114514</span>)</span></span>;<span class="comment">//声明函数func</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">114514</span>, <span class="type">int</span> b = <span class="number">114514</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能代码本身在编译器不会报错，但是运行之后会出现如下错误信息</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301302240605.png" alt="image-20230130224011549"></p><h2 id="②函数占位参数"><a href="#②函数占位参数" class="headerlink" title="②函数占位参数"></a>②函数占位参数</h2><p>C++中函数的形参列表里是可以和有占位参数，<code>用来进行占位，调用函数时候必须补该位置</code>。</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名 (数据类型)&#123;&#125;</span><br></pre></td></tr></table></figure><p>比如以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//占位参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功调用func函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>）;<span class="comment">//必须在括号内输入一个整形数据才能成功调用，起到占位的作用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面学的内容，其实占位参数也可以进行赋予基础值，比如以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//占位参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;成功调用func函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//必须在括号内输入一个整形数据才能成功调用，起到占位的作用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这样起到的作用与①中相似，不过占位参数只需要作为了解，等到后面才能发挥其大用。</p><h2 id="③函数重载"><a href="#③函数重载" class="headerlink" title="③函数重载"></a>③函数重载</h2><h3 id="（1）函数重载的概述"><a href="#（1）函数重载的概述" class="headerlink" title="（1）函数重载的概述"></a>（1）函数重载的概述</h3><p>作用：函数名可以相同，<code>提高复用性</code>。</p><p><strong>函数重载满足条件：</strong>-</p><p>1、处于同一作用域下</p><p>2、函数名称相同</p><p>3、函数<code>参数类型不同</code>，或者<code>个数不同或者顺序不同</code>。</p><p>比如以下的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下函数都处于全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func 调用成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a) 调用成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(double a) 调用成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a,float b) 调用成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(float a, int b)调用成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上四个函数分别可以代表几个点，然后输出结果如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301310037097.png" alt="image-20230131003700032"></p><p>都是通过参数类型的不同以及位置的不同来进行调用同名的函数。</p><p><strong>注意：</strong>函数的返回值不可以作为函数重载的条件</p><p>不然会出现以下的报错信息</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301310038535.png" alt="image-20230131003826498"></p><h3 id="（2）函数重载的注意事项"><a href="#（2）函数重载的注意事项" class="headerlink" title="（2）函数重载的注意事项"></a>（2）函数重载的注意事项</h3><p><code>1、引用作为重载条件</code></p><p>如以下的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(int&amp; a)调用成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(const int&amp; a)调用成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func</span>(a);<span class="comment">//此时实参是一个操控内存空间的变量a，所以应当调用第一个func</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下位输出结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301310044703.png" alt="image-20230131004420633"></p><p>如果我们将实参变为一个常量呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(int&amp; a)调用成功！&quot;</span> &lt;&lt; endl;<span class="comment">//int &amp;a = 10//不合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span> <span class="comment">// const int&amp;a = 10//合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(const int&amp; a)调用成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//此时实参为常量10，为什么调用了第二个函数也可以看上面关于是否合法的解释</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301310045524.png" alt="image-20230131004512457"></p><p>我们会发现常量引用在参数列表的函数被成功调用了，这就是引用在函数重载之间的不同点。</p><p><code>2、函数重载碰到默认参数</code></p><p>对于函数重载碰到默认参数，究竟会碰出什么样的花火呢？比如以下的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(int a, int b = 10)成功调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(int a)成功调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这个例子编译器就会蒙圈，因为第一个函数和第二个函数都能满足调用的情况，所以编译器就不清楚应该调用哪个函数所以会产生报错，报错信息如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301310056175.png" alt="image-20230131005601097"></p><p>这就是函数重载碰到默认参数，出现了<code>二义性</code>。一般这种歧义都要尽量避免。</p><p>但是上面的那个真的就都不能进行调用了吗？其实我们稍作修改就可以调用第一个函数！比如以下的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(int a, int b = 10)成功调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func(int a)成功调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301310056999.png" alt="image-20230131005638921"></p>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="C++" scheme="https://bg.luoxi.work/categories/C/"/>
    
    
    <category term="C++" scheme="https://bg.luoxi.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>引用</title>
    <link href="https://bg.luoxi.work/2023/01/30/2023/Mon/11/"/>
    <id>https://bg.luoxi.work/2023/01/30/2023/Mon/11/</id>
    <published>2023-01-30T08:00:00.000Z</published>
    <updated>2023-01-30T16:10:33.995Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="①引用的基本使用"><a href="#①引用的基本使用" class="headerlink" title="①引用的基本使用"></a>①引用的基本使用</h2><p><strong>作用：</strong>给变量起别名</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 &amp;别名 = 原名</span><br></pre></td></tr></table></figure><p>以下为引用的一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//创建引用</span></span><br><span class="line">    <span class="type">int</span>&amp; b = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b = <span class="number">114514</span>;<span class="comment">//即使是别名也可以操控内存</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②引用注意事项"><a href="#②引用注意事项" class="headerlink" title="②引用注意事项"></a>②引用注意事项</h2><p>1、引用必须初始化</p><p>2、引用在初始化后，不可以改变</p><p>例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>  b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//int &amp;c;//错误，引用必须初始化</span></span><br><span class="line">    <span class="type">int</span>&amp; c = a;<span class="comment">//一旦初始化后就不可以更改</span></span><br><span class="line">    c = b;<span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果：</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301282330135.png" alt="image-20230128233055057"></p><h2 id="③引用做函数参数"><a href="#③引用做函数参数" class="headerlink" title="③引用做函数参数"></a>③引用做函数参数</h2><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参。</p><p><strong>优点：</strong>可以简化指针修饰实参。</p><p>比如以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;in swap01 a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;in swap01 b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a ^= b ^= a ^= b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">114514</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1919810</span>;</span><br><span class="line"><span class="comment">/*mySwap01(a, b);*/</span><span class="comment">//值传递，形参不会修饰实参</span></span><br><span class="line"><span class="comment">/*mySwap02(&amp;a, &amp;b);*/</span><span class="comment">//地址传递，形参会修饰实参</span></span><br><span class="line"><span class="built_in">mySwap03</span>(a, b);<span class="comment">//引用传递，形参会修饰实参</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这串代码的<code>mySwap03</code>函数的参数列表中的<code>int &amp;a</code>和<code>int &amp;b</code>分别对应的是实参a和b的别名，即在函数<code>mySwap03</code>的别名，可以通过别名之间值的交换来达到实参的值的交换，对比<code>mySwap01</code>就是多了<code>&amp;</code>。</p><p>以下为上面代码的输出结果：</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301291653501.png" alt="image-20230129165333418"></p><h2 id="④引用做函数的返回值"><a href="#④引用做函数的返回值" class="headerlink" title="④引用做函数的返回值"></a>④引用做函数的返回值</h2><p><strong>作用：</strong>引用是可以作为函数的返回值存在的</p><p><strong>注意：</strong>不要返回局部变量的引用，因为局部变量在栈上，随着函数的结束而被释放。</p><p>用法：函数调用作为左值</p><p>对于用法的功能如下面代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用做函数的返回值</span></span><br><span class="line"><span class="comment">//1、不要返回局部变量的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">114514</span>;<span class="comment">//局部变量存放在四区中的栈区，出函数自动释放</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、函数的调用可以作为左值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">114514</span>;<span class="comment">//加了static关键字变成了静态全局变量，随着程序的结束而释放</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int&amp; b = test01();</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; b &lt;&lt; endl;// 第一次编译器做了保留</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数的调用可以作为左值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp; c = <span class="built_in">test02</span>();</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>() = <span class="number">1919810</span>;<span class="comment">//函数的调用被当作左值</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;<span class="comment">//因为c相当于是函数调用的别名，函数调用作为左值被修改，c就跟着也被修改</span></span><br><span class="line">cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301291733158.png" alt="image-20230129173325080"></p><p>对test01函数的结果其实跟内存四区中不能把局部变量当为返回值一样，是因为出了函数将会被释放，而第一次编译器会做保留。</p><h2 id="⑤引用的本质"><a href="#⑤引用的本质" class="headerlink" title="⑤引用的本质"></a>⑤引用的本质</h2><p><strong>本质：</strong>引用的本质在C++内部实现是一个<code>指针常量</code></p><p>比如通过以下的图解</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301302144378.png" alt="image-20230130214417244"></p><h2 id="⑥常量引用"><a href="#⑥常量引用" class="headerlink" title="⑥常量引用"></a>⑥常量引用</h2><p>作用：常量引用主要来修饰形参，防止误操作。</p><p>像通过（5）我们能够清楚引用的本质是个常量指针所以引用必须引一块合法的内存空间，不然会出现以下的报错</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301302203523.png" alt="image-20230130220347467"></p><p>但是加上了const就不一样了，比如以下的代码</p><p>如果我们不用const，不小心在实现打印功能的函数里面修改了形参的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pritnffunc</span><span class="params">(<span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = <span class="number">1919810</span>;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;在Printfunc a = &quot;</span>&lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//常量引用</span></span><br><span class="line"><span class="comment">//使用场景：用来修饰形参，防止误操作</span></span><br><span class="line"><span class="comment">/*int a = 10;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加上const之后 编译器将代码识别修改为 int temp = 10; int &amp;b = temp;</span></span><br><span class="line"><span class="comment">//const int&amp; b = 10;//引用必须引一块合法的内存空间</span></span><br><span class="line"><span class="comment">//所以下面就不能对b进行修改了 </span></span><br><span class="line"><span class="comment">//b = 114514;//加入const之后变成为只读，不可以修改。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比如我们想用个函数实现打印的功能</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">Pritnffunc</span>(a);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;在main a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<span class="comment">//</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301302211367.png" alt="image-20230130221103289"></p><p>我们发现这样导致值被修改了，如果我们加入了const呢？</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301302212294.png" alt="image-20230130221204229"></p><p>就会出现如上图的报错，通过const关键字修饰可以很好的避免误操作导致形参改变了实参的值。</p>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="C++" scheme="https://bg.luoxi.work/categories/C/"/>
    
    
    <category term="C++" scheme="https://bg.luoxi.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>内存分区模型</title>
    <link href="https://bg.luoxi.work/2023/01/29/2023/Mon/10/"/>
    <id>https://bg.luoxi.work/2023/01/29/2023/Mon/10/</id>
    <published>2023-01-29T08:00:00.000Z</published>
    <updated>2023-01-30T16:10:13.125Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>C++程序在执行中时，将内存划分为<code>4个区域</code></p><p><strong>1、代码区</strong>：存放函数的二进制代码，由操作系统进行管理。</p><p><strong>2、全局区</strong>：存放全局变量和静态变量以及常量。</p><p><strong>3、栈区</strong>：由编译器自动分配释放，存放函数的参数值，局部变量。</p><p><strong>4、堆区</strong>：由程序员分配和释放，若程序员不释放，结束时由操作系统回收</p><p><strong>内存四区的意义:</strong></p><p>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程。</p><h2 id="①程序运行前"><a href="#①程序运行前" class="headerlink" title="①程序运行前"></a>①程序运行前</h2><p>在程序编译后，生成了exe可执行程序，<code>未执行该程序前分为两个区域</code>。</p><p>以下为内存四区的特点</p><p><strong>代码区：</strong></p><p>1、存放CPU执行的机器命令</p><p>2、代码区是<code>共享</code>的,共享的目的是<code>对于频繁被执行的程序，只需要在内存中有一份代码即可</code>。（比如每执行了一次代码结束之后，就会生存一个exe文件，存储了之前执行成功的那份代码）</p><p>3、代码区是<code>只读</code>的，使其制度的原因是<code>防止程序意外的修改了它的代码</code></p><p><strong>全局区：</strong></p><p>1、全局变量和静态变量存放在此。</p><p>2、全局区还包含了<code>常量区</code>，<code>字符串常量</code>和<code>其他常量</code>也存放在此。</p><p>3、<code>读区域的数据在程序结束后由操作系统释放</code>。</p><p>那么对于全局区和不在全局区的变量究竟有什么样的区别呢？我们来看下面的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰的全局变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 全局区</span></span><br><span class="line">    <span class="comment">// 全局变量、静态变量、常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建普通的局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量a的地址为: &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量b的地址为: &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_a的地址为: &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_a的地址为: &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_a的地址为: &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_b的地址为: &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="comment">// 字符串常量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串常量的地址为: &quot;</span> &lt;&lt; (<span class="type">int</span>)<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const修饰的变量</span></span><br><span class="line">    <span class="comment">// const修饰的全局变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_a的地址为: &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_b的地址为: &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// const修饰的局部变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_a的地址为: &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_b的地址为: &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_b &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码的输出结果如下:<br><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301282110148.png" alt="image-20230128211013957"></p><p>我们可以发现处于全局区的变量地址十分相近，而局部变量就和全局区的变量相差很大，大概的图解如下。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301282116525.png" alt="image-20230128211634405"></p><h2 id="②程序运行后"><a href="#②程序运行后" class="headerlink" title="②程序运行后"></a>②程序运行后</h2><p><strong>栈区:</strong></p><p>1、由编译器自动分配释放，存放函数的参数值，局部变量等</p><p><strong>2、注意事项</strong>：<code>不要返回局部变量的地址</code>，栈区开辟的数据由编译器自动释放。</p><p>注意事项中的实例如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span><span class="comment">//在函数参数列表的变量也存放在栈区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//局部变量 存放在栈区，栈区的数据在函数执行完后自动释放</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a;<span class="comment">//返回局部变量的地址。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//接收func函数的返回值 </span></span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">func</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//第一个可以打印正确的数字是因为编译器做了保留</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;<span class="comment">//第二次这个数据就不在保留了</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 由于多种编译器打印结果不一样，以下展示DEVC++，VSCODE，VS2019的结果</p><p><strong>DEVC++：</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301282133584.png" alt="image-20230128213301511"></p><p><strong>VSCODE：</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301282133388.png" alt="image-20230128213326319"></p><p><strong>报错信息:</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301282133856.png" alt="image-20230128213350814"></p><p><strong>VS2019:</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301282134134.png" alt="image-20230128213438074"></p><p>虽然可能编译器不同会产生不同的结果，但是对于这样错误的做法仍然不推荐！！！</p><p><strong>堆区:</strong></p><p>1、由程序员分配释放，若程序员不释放，<code>程序结束时由操作系统回收</code>。</p><p>2、在C++主要利用<code>new</code>在堆区开辟内存。 </p><p> 对于1、的解释我们可以用如下例子帮忙理解，同样是上面的代码，但是不太相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">func</span><span class="params">()</span> <span class="comment">// 在函数参数列表的变量也存放在栈区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//利用nex关键字 可以讲数据开辟在堆区</span></span><br><span class="line">    <span class="comment">//指针 本质也是局部变量，放在战上，指针保存的数据（堆区的编号地址）是放在堆区的。</span></span><br><span class="line">    <span class="type">int</span> *a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//用new关键字在堆区开辟数据并返回地址</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 接收func函数的返回值</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 第一个可以打印正确的数字是因为编译器做了保留</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">// 第二次这个数据就不在保留了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时打印的结果就无论如何都是对应的结果了</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301282144905.png" alt="image-20230128214425834"></p><p>对于上面的代码堆区以及栈区的图解如下：<br><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301282149613.png" alt="image-20230128214911547"></p><h2 id="③new操作符"><a href="#③new操作符" class="headerlink" title="③new操作符"></a>③new操作符</h2><p>C++中利用<code>new</code>操作符在堆区开辟数据</p><p>堆区开辟的数据，由程序员手动开辟，手动释放、释放利用操作符<code>delete</code></p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 数据类型</span><br></pre></td></tr></table></figure><p><code>利用new创建的数据，会返回该数据对应的类型指针。</code></p><p>对于new的基本语法，如下例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、new的基本语法</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在堆区创建一个整形的数据</span></span><br><span class="line">    <span class="comment">//new返回的是该数据类型的指针</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试案例一</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"><span class="comment">/*    delete p;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; *p &lt;&lt; endl;*/</span><span class="comment">//当程序执行到此处会报错，此操作非法</span></span><br><span class="line">    <span class="comment">//堆区的数据由程序员管理开辟，程序员来进行管理释放</span></span><br><span class="line">    <span class="comment">//如果想释放堆区的数据，利用关键字delete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试案例二</span></span><br><span class="line"><span class="comment">//在堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在堆区创建10整形数据的数组</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//10代表数组由十个元素,返回数组连续空间的首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操控数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = <span class="number">100</span> + i;<span class="comment">//给10个元素赋值100-109</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证数据是否有</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放堆区的数组</span></span><br><span class="line">    <span class="comment">//释放数组的时候，要加[]才可以</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果:</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301282307395.png" alt="image-20230128230715320"></p>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="C++" scheme="https://bg.luoxi.work/categories/C/"/>
    
    
    <category term="C++" scheme="https://bg.luoxi.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>结构体数组和结构体指针</title>
    <link href="https://bg.luoxi.work/2023/01/23/2023/Mon/9/"/>
    <id>https://bg.luoxi.work/2023/01/23/2023/Mon/9/</id>
    <published>2023-01-23T08:00:00.000Z</published>
    <updated>2023-01-23T08:13:01.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="结构体数组和结构体指针"><a href="#结构体数组和结构体指针" class="headerlink" title="结构体数组和结构体指针"></a>结构体数组和结构体指针</h1><h2 id="①结构体数组"><a href="#①结构体数组" class="headerlink" title="①结构体数组"></a>①结构体数组</h2><h3 id="（1）定义结构体数组"><a href="#（1）定义结构体数组" class="headerlink" title="（1）定义结构体数组"></a>（1）定义结构体数组</h3><p>定义结构体数组有多种方法：</p><p>第一种方法是在声明结构体的时候进行定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">结构体成员;</span><br><span class="line">&#125; 数组名[长度];</span><br></pre></td></tr></table></figure><p>第二种方法是先声明一个结构体类型（比如上面的Book），再用此类型定义一个结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">结构体成员;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称 数组名[长度];</span></span><br></pre></td></tr></table></figure><h3 id="（2）初始化结构体数组"><a href="#（2）初始化结构体数组" class="headerlink" title="（2）初始化结构体数组"></a>（2）初始化结构体数组</h3><p>我们也可以在定义结构体数组的时候将它进行初始化，比如以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">144</span>];</span><br><span class="line">    <span class="type">char</span> tag[<span class="number">40</span>];</span><br><span class="line">    <span class="type">char</span> gametag[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span> <span class="title">gal</span>[3] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;《ATRI》&quot;</span>, <span class="string">&quot;催泪&quot;</span>, <span class="string">&quot;全年龄&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;《星空列车与白的旅行》&quot;</span>, <span class="string">&quot;催泪&quot;</span>, <span class="string">&quot;全年龄&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;《Loopers》&quot;</span>, <span class="string">&quot;催泪&quot;</span>, <span class="string">&quot;全年龄&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="（3）结构体数组的访问"><a href="#（3）结构体数组的访问" class="headerlink" title="（3）结构体数组的访问"></a>（3）结构体数组的访问</h3><p>如果想要访问结构体数组，可能和前面访问数组有点类似，用到循环可以达到快速访问数组所有元素，数组内结构体所包含的元素用结构体的访问方法即可，代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">144</span>];</span><br><span class="line">    <span class="type">char</span> tag[<span class="number">40</span>];</span><br><span class="line">    <span class="type">char</span> gametag[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span> <span class="title">gal</span>[3] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;《ATRI》&quot;</span>, <span class="string">&quot;催泪&quot;</span>, <span class="string">&quot;全年龄&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;《星空列车与白的旅行》&quot;</span>, <span class="string">&quot;催泪&quot;</span>, <span class="string">&quot;全年龄&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;《Loopers》&quot;</span>, <span class="string">&quot;催泪&quot;</span>, <span class="string">&quot;全年龄&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;======================\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;作品名字: %s\n&quot;</span>, gal[i].title);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;作品类型: %s\n&quot;</span>, gal[i].tag);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;游戏类型: %s\n&quot;</span>, gal[i].gametag);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;======================\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示:</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301231536440.png" alt="image-20230123153652354"></p><h2 id="②结构体指针"><a href="#②结构体指针" class="headerlink" title="②结构体指针"></a>②结构体指针</h2><h3 id="（1）定义结构体指针"><a href="#（1）定义结构体指针" class="headerlink" title="（1）定义结构体指针"></a>（1）定义结构体指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">144</span>];</span><br><span class="line">    <span class="type">char</span> tag[<span class="number">40</span>];</span><br><span class="line">    <span class="type">char</span> gametag[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span> *<span class="title">pt</span>//定义结构体指针</span></span><br></pre></td></tr></table></figure><p>如果我们要把结构体指针指向一个已经初始化的结构体变量的话一定要在结构体变量名前加上<code>&amp;</code>因为结构体的变量名不像数组那样</p><p>比如以下例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">144</span>];</span><br><span class="line">    <span class="type">char</span> tag[<span class="number">40</span>];</span><br><span class="line">    <span class="type">char</span> gametag[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span> <span class="title">gal</span> =</span> &#123;<span class="string">&quot;《ATRI》&quot;</span>, <span class="string">&quot;催泪&quot;</span>, <span class="string">&quot;全年龄&quot;</span>&#125;,</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span> *<span class="title">pt</span> =</span> &amp;gal; <span class="comment">// 定义结构体指针</span></span><br></pre></td></tr></table></figure><h3 id="（2）利用结构体指针访问"><a href="#（2）利用结构体指针访问" class="headerlink" title="（2）利用结构体指针访问"></a>（2）利用结构体指针访问</h3><p>通过结构体指针访问结构体成员有两种方法</p><p><strong>第一种：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*结构体指针).成员名<span class="comment">//注意小括号，不然根据运算符优先级是先运算&quot;.&quot;</span></span><br></pre></td></tr></table></figure><p><strong>第二种（常用）：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体指针-&gt;成员名</span><br></pre></td></tr></table></figure><p>比如以下的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">144</span>];</span><br><span class="line">    <span class="type">char</span> tag[<span class="number">40</span>];</span><br><span class="line">    <span class="type">char</span> gametag[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span> <span class="title">gal</span> =</span> &#123;<span class="string">&quot;《ATRI》&quot;</span>, <span class="string">&quot;催泪&quot;</span>, <span class="string">&quot;全年龄&quot;</span>&#125;,</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span> *<span class="title">pt</span> =</span> &amp;gal; <span class="comment">// 定义结构体指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;作品名字: %s\n&quot;</span>, pt-&gt;title);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;作品类型: %s\n&quot;</span>, pt-&gt;tag);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;游戏类型: %s\n&quot;</span>, pt-&gt;gametag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301231611907.png" alt="image-20230123161130835"></p>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="c语言" scheme="https://bg.luoxi.work/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://bg.luoxi.work/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>结构体初步</title>
    <link href="https://bg.luoxi.work/2023/01/22/2023/Mon/8/"/>
    <id>https://bg.luoxi.work/2023/01/22/2023/Mon/8/</id>
    <published>2023-01-22T08:00:00.000Z</published>
    <updated>2023-01-23T08:45:59.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="结构体初步"><a href="#结构体初步" class="headerlink" title="结构体初步"></a>结构体初步</h1><h2 id="①结构体的声明"><a href="#①结构体的声明" class="headerlink" title="①结构体的声明"></a>①结构体的声明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    结构体成员<span class="number">1</span>;</span><br><span class="line">    结构体成员<span class="number">2</span>;</span><br><span class="line">    结构体成员<span class="number">3</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;<span class="comment">//注意分号</span></span><br><span class="line"><span class="comment">//比如以下的声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> date;</span><br><span class="line">    <span class="type">char</span> publisher[<span class="number">40</span>];</span><br><span class="line">&#125;;<span class="comment">//用结构体变量存储一本书籍的诸多信息</span></span><br></pre></td></tr></table></figure><h2 id="②结构体的定义"><a href="#②结构体的定义" class="headerlink" title="②结构体的定义"></a>②结构体的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称 结构体变量名</span></span><br></pre></td></tr></table></figure><p> 比如以下的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="type">float</span> price;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> date;</span><br><span class="line">    <span class="type">char</span> publisher[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">book</span>;</span><span class="comment">//定义结构体变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="③结构体的访问"><a href="#③结构体的访问" class="headerlink" title="③结构体的访问"></a>③结构体的访问</h2><p>要访问结构体的成员，我们需要引入一个新的运算符 – 点号(.)运算符。比如book.title就是引用book结构体的title成员，它是一个字符数组;而book.price则是引用book结构体的price成员，它是一个浮点型的变量。</p><p>比如以下的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">book</span>;</span> <span class="comment">// 定义结构体变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入书名:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, book.title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入作者:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, book.author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=====数据录入完毕=====\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;书名:%s\n&quot;</span>, book.title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作者:%s\n&quot;</span>, book.author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;===================\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果:</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301221118706.png" alt="image-20230122111807635"></p><h2 id="④结构体变量的一般初始化"><a href="#④结构体变量的一般初始化" class="headerlink" title="④结构体变量的一般初始化"></a>④结构体变量的一般初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> contry[<span class="number">40</span>];</span><br><span class="line">&#125; book = &#123;</span><br><span class="line">    <span class="string">&quot;《星空列车与白的旅行》&quot;</span>,</span><br><span class="line">    <span class="string">&quot;日本galgame&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注: 结构体变量的类型必须对号入座，比如我上面写的都是字符串类型，所以也就只能用字符串类型。</strong> </p><h2 id="⑤初始结构体的指定成员值"><a href="#⑤初始结构体的指定成员值" class="headerlink" title="⑤初始结构体的指定成员值"></a>⑤初始结构体的指定成员值</h2><p>语法和数组类似，不过结构体指定初始化成员使用点号(.)运算符和成员名。</p><p>比如我们可以让程序只初始化Book的price成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">book</span> =</span> &#123;.price = <span class="number">48.8</span>&#125;;</span><br></pre></td></tr></table></figure><p>还可以不按结构体声明的成员顺序进行初始化 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BOOk</span> <span class="title">book</span> =</span> &#123;</span><br><span class="line">    .publisher = <span class="string">&quot;清华大学出版社&quot;</span>,</span><br><span class="line">    .price = <span class="number">4838</span>,</span><br><span class="line">    .date = <span class="number">20171111</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="⑥结构体变量所占的内存空间"><a href="#⑥结构体变量所占的内存空间" class="headerlink" title="⑥结构体变量所占的内存空间"></a>⑥结构体变量所占的内存空间</h2><p>关于结构体变量所占的空间内存，先给出几个例子来看最后的结果。</p><p><strong>例子1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];<span class="comment">//128</span></span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];<span class="comment">//40</span></span><br><span class="line">    <span class="type">float</span> price;<span class="comment">//4</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> date;<span class="comment">//4</span></span><br><span class="line">    <span class="type">char</span> publisher[<span class="number">40</span>];<span class="comment">//40</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;struct Book sizeof = %d&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Book));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子2:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title;<span class="comment">//1</span></span><br><span class="line">    <span class="type">int</span> price;<span class="comment">//4</span></span><br><span class="line">    <span class="type">char</span> author;<span class="comment">//1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;struct Book sizeof = %d&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Book));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子3:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title;<span class="comment">//1</span></span><br><span class="line">    <span class="type">char</span> author;<span class="comment">//1</span></span><br><span class="line">    <span class="type">int</span> price;<span class="comment">//4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;struct Book sizeof = %d&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Book));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子4:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> m[<span class="number">5</span>];<span class="comment">//5</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> c;<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> j;<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">    &#125; ss; </span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> a[<span class="number">4</span>];<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;struct Book sizeof = %d&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Book));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面四个例子输出结果分别是</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301221135642.png" alt="image-20230122113512567"></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301221135908.png" alt="image-20230122113535843"></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301221136411.png" alt="image-20230122113601346"></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301221447062.png" alt="image-20230122144740964"></p><p>看到上面的结果可能会感觉很奇怪？如果结构体内部如例子2一样的话应该常理来说是占6个字节啊，可是为什么却占了12个字节？其实这之间发生了<code>内存对齐</code>。</p><p>内存对齐一般都占小字节的类型向占最大字节(<strong>除去字符串类型以及结构体类型之外</strong>)的类型保持一致,比如以下图解。</p><p><strong>例子1:</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301221501845.png" alt="image-20230122150108781"></p><p><strong>例子2:</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301221506165.png" alt="image-20230122150626105"></p><p><strong>例子3:</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301221512898.png" alt="image-20230122151215853"></p><p><strong>例子4:</strong></p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301221520068.png" alt="image-20230122152057996"></p><h2 id="⑦结构体嵌套"><a href="#⑦结构体嵌套" class="headerlink" title="⑦结构体嵌套"></a>⑦结构体嵌套</h2><p>对⑥中例子的代码，我们可以发现，其实结构体也可以发生嵌套，而其实有时候我们是需要结构体的嵌套来完成一些事情的，比如以下例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">40</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">date</span>;</span></span><br><span class="line">&#125; book = &#123;</span><br><span class="line">    <span class="string">&quot;《约会大作战》&quot;</span>,</span><br><span class="line">    <span class="string">&quot;橘公司&quot;</span>,</span><br><span class="line">    &#123;<span class="number">2012</span>, <span class="number">4</span>, <span class="number">26</span>&#125; <span class="comment">// 同样的方式进行初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;书名 : %s\n&quot;</span>, book.title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作者 : %s\n&quot;</span>, book.author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;日期 : %d-%d-%d&quot;</span>, book.date.year, book.date.month, book.date.day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301222159821.png" alt="image-20230122215923716"></p><h2 id="⑧结构体变量的传递"><a href="#⑧结构体变量的传递" class="headerlink" title="⑧结构体变量的传递"></a>⑧结构体变量的传递</h2><p>对于结构体变量其实可以想其他变量一样，将<code>同类型的变量</code>进行相互赋值，比如以下的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">144</span>];</span><br><span class="line">    <span class="type">char</span> tag[<span class="number">40</span>];</span><br><span class="line">    <span class="type">char</span> gametag[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Gal</span> <span class="title">gal1</span> =</span> &#123;<span class="string">&quot;《ATRI》&quot;</span>, <span class="string">&quot;催泪&quot;</span>, <span class="string">&quot;全年龄&quot;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Gal</span> <span class="title">gal2</span> =</span> &#123;<span class="string">&quot;《Loopers》&quot;</span>, <span class="string">&quot;催泪&quot;</span>, <span class="string">&quot;全年龄&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//交换gal1和gal2的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Gal</span> <span class="title">temp</span> =</span> gal1;</span><br><span class="line">    gal1 = gal2;</span><br><span class="line">    gal2 = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作品名字: %s\n&quot;</span>, gal1.title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作品类型: %s\n&quot;</span>, gal1.tag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;游戏类型: %s\n&quot;</span>, gal1.gametag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;======================\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作品名字: %s\n&quot;</span>, gal2.title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作品类型: %s\n&quot;</span>, gal2.tag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;游戏类型: %s\n&quot;</span>, gal2.gametag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;======================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301231630784.png" alt="image-20230123163003688"></p><p>但是注意一点，就是必须两个<code>结构体类型完全一致</code>才能进行交换和互相赋值！！！</p><h2 id="⑨结构体函数"><a href="#⑨结构体函数" class="headerlink" title="⑨结构体函数"></a>⑨结构体函数</h2><p>其实结构体也可以作为函数的返回值，比如看下个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Gal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> title[<span class="number">144</span>];</span><br><span class="line">    <span class="type">char</span> tag[<span class="number">40</span>];</span><br><span class="line">    <span class="type">char</span> gametag[<span class="number">40</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Gal <span class="title function_">ChangeGal</span><span class="params">(<span class="keyword">struct</span> Gal gal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 利用字符串处理函数将结构体的值进行修改</span></span><br><span class="line">    <span class="built_in">strcpy</span>(gal.title, <span class="string">&quot;《星空列车与白的旅行》&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(gal.tag, <span class="string">&quot;催泪&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(gal.gametag, <span class="string">&quot;全年龄&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Gal</span> <span class="title">gal1</span> =</span> &#123;<span class="string">&quot;《ATRI》&quot;</span>, <span class="string">&quot;催泪&quot;</span>, <span class="string">&quot;全年龄&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进入ChangGal函数之前:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作品名字: %s\n&quot;</span>, gal1.title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作品类型: %s\n&quot;</span>, gal1.tag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;游戏类型: %s\n&quot;</span>, gal1.gametag);</span><br><span class="line">    gal1 = ChangeGal(gal1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进入ChangGal函数之后:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作品名字: %s\n&quot;</span>, gal1.title);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;作品类型: %s\n&quot;</span>, gal1.tag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;游戏类型: %s\n&quot;</span>, gal1.gametag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面用到的字符串处理函数不懂的可以参考我以前的博客：<a href="https://bg.luoxi.work/2022/12/01/DEnot/1/">❤️</a></p><p>以下为输出结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301231644722.png" alt="image-20230123164429626"></p><p>可以看到结构体其实也可以作为函数的返回值！</p>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="c语言" scheme="https://bg.luoxi.work/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://bg.luoxi.work/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>动态内存管理</title>
    <link href="https://bg.luoxi.work/2023/01/21/2023/Mon/6/"/>
    <id>https://bg.luoxi.work/2023/01/21/2023/Mon/6/</id>
    <published>2023-01-21T08:00:00.000Z</published>
    <updated>2023-01-20T16:07:48.047Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h1><h2 id="①内存管理函数"><a href="#①内存管理函数" class="headerlink" title="①内存管理函数"></a>①内存管理函数</h2><p>当我们对于一个数组<code>申请内存空间</code>的时候，一开始我们<code>都必须先定义好数组的长度来进行存放相应的数据</code>，或者采用<code>宏定义的方式来进行修改宏定义相应的值来改变数组的长度</code>。那有没有一种方式能够动态的申请我们所需要的空间呢？其实只需要调用&lt;stdlib.h&gt;头文件的库函数中的动<code>态内存管理相应的函数</code>就能灵活的实现此功能，大大的提高了效率！</p><p>下面将展示常用的几个内存管理的函数，</p><p><code>malloc</code>：申请动态内存空间。</p><p><code>free</code>：释放动态内存空间。</p><p><code>calloc</code> :  申请并初始化一系列内存空间。</p><p><code>realloc</code>：重新分配内存空间。</p><h3 id="（1）malloc"><a href="#（1）malloc" class="headerlink" title="（1）malloc"></a>（1）malloc</h3><p><strong>函数原型:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;<span class="comment">//使用void类型是因为void类型可以转换为任何一种类型的空间</span></span><br></pre></td></tr></table></figure><p><code>malloc</code>函数向系统申请分配size个字节的内存空间，并返回一个指向这块空间的指针。</p><p>如果<code>函数调用成功</code>，<code>返回一个指向申请的内存空间的指针</code>，由于返回类型是void指针(void *)，所以它可以被转换为任何类型的数据；如果<code>函数调用失败</code>，<code>返回值是NULL</code>。另外，如果<code>size参数设置为零</code>，<code>返回值也可能是NULL</code>，但这并不意味着函数调用失败。</p><p>下面我们用一串代码来展示它的作用吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你输入的整数是:%d\n&quot;</span>, *(<span class="type">int</span> *)ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301202153334.png" alt="image-20230120215354273"></p><p>可能很多人觉得有没有malloc其实都一样，但是用malloc申请的内存之后，这个内存是位于<code>堆</code>上的，他<code>不会</code>因为出了作用域而<code>被程序自动释放</code>，而是需要<code>程序员自己进行释放或者程序结束</code>。而于它相对的是<code>栈</code>。所以以上的代码是存在一个错误就是没有释放内存，这样会导致<code>内存泄漏</code>。那么我们应该怎么释放呢？那就要用到<code>free</code>函数了</p><h3 id="（2）free"><a href="#（2）free" class="headerlink" title="（2）free"></a>（2）free</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br></pre></td></tr></table></figure><p>free函数释放ptr参数指向的内存空间。<code>该内存空间必须是由malloc,calloc,或realloc函数申请的。否则，该函数将导致未定义行为</code>。如果ptr参数是NULL，则不执行任何操作。</p><p><strong>注意：该函数并不会修改ptr参数的值，所以调用后它仍然指向原来的地方（变为非法空间）。</strong></p><p>所以上面的代码我们需要稍作一点点修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你输入的整数是:%d\n&quot;</span>, *(<span class="type">int</span> *)ptr);</span><br><span class="line">    <span class="built_in">free</span> (ptr);<span class="comment">//释放占用的堆内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果我们提前用free函数进行释放的话</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">// 释放占用的堆内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你输入的整数是:%d\n&quot;</span>, *(<span class="type">int</span> *)ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时输出的结果就会很奇怪</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301202210646.png" alt="image-20230120221017570"></p><h3 id="（3）calloc"><a href="#（3）calloc" class="headerlink" title="（3）calloc"></a>（3）calloc</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>上面形式的意思是：</p><p>calloc函数在内存中动态地申请nmemb个长度为size的内存空间（即申请的总空间尺寸为nmemb*size），这些内存空间全部被初始化为0。</p><p>calloc函数于malloc函数的一个重要区别是：</p><p><strong>calloc函数在申请完内存后，自动初始化该内存空间为0。</strong></p><p><strong>malloc函数不进行初始化操作，里边数据是随机的。</strong></p><p>比如以下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = (<span class="type">void</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*ptr:%d\n&quot;</span>, *(<span class="type">int</span> *)ptr);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301202330984.png" alt="image-20230120233012904"></p><h3 id="（4）realloc"><a href="#（4）realloc" class="headerlink" title="（4）realloc"></a>（4）realloc</h3><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br></pre></td></tr></table></figure><p>realloc函数是C语言标准库中的一个函数，用于<code>重新分配内存</code>。它可以<code>更改已分配内存的大小</code>，并返回指向新内存块的指针。</p><p>以下由几点需要注意：</p><p>1.realloc函数修改ptr指向的内存空间大小为size字节</p><p>2.如果新分配的内存空间比原来的打，则旧内存块的数据不会发生改变，如果新的内存空间大小小于旧的内存空间，可能会导致数据丢失！</p><p>3.该函数将移动内存空间的数据并返回新的指针</p><p>4.<strong>如果ptr参数为NULL，那么调用该函数就相当于调用malloc(size)。</strong></p><p>以下用一串代码来展示它的作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, num;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">NULL</span>; <span class="comment">// 注意！这里必须初始化为NULL！</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数(输入 -1表示结束):&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        count++;</span><br><span class="line">        ptr = (<span class="type">int</span> *)<span class="built_in">realloc</span>(ptr, count * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 实时根据要求重新分配空间</span></span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ptr[count - <span class="number">1</span>] = num;</span><br><span class="line">    &#125; <span class="keyword">while</span> (num != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入的整数分别是:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301210002460.png" alt="image-20230121000239380"></p><h2 id="②内存泄漏"><a href="#②内存泄漏" class="headerlink" title="②内存泄漏"></a>②内存泄漏</h2><p>程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><p>导致内存泄漏主要有两种情况：</p><p><strong>1.隐式内存泄漏（即用完内存块没有及时使用free函数释放）</strong></p><p><strong>2.丢失内存地址</strong></p><p>对于2的情况比如以下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = (<span class="type">void</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> a = <span class="number">520</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你输入的整数是:%d\n&quot;</span>, *(<span class="type">int</span> *)ptr);</span><br><span class="line">    ptr = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你输入的整数是:%d\n&quot;</span>, *(<span class="type">int</span> *)ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="c语言" scheme="https://bg.luoxi.work/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://bg.luoxi.work/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>高级宏定义</title>
    <link href="https://bg.luoxi.work/2023/01/21/2023/Mon/7/"/>
    <id>https://bg.luoxi.work/2023/01/21/2023/Mon/7/</id>
    <published>2023-01-21T08:00:00.000Z</published>
    <updated>2023-01-22T04:52:01.422Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="高级宏定义"><a href="#高级宏定义" class="headerlink" title="高级宏定义"></a>高级宏定义</h1><h2 id="①不带参数的宏定义"><a href="#①不带参数的宏定义" class="headerlink" title="①不带参数的宏定义"></a>①不带参数的宏定义</h2><p>基本形式例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure><p>关于宏定义需要注意以下几点：</p><p>1.为了和普通的变量进行区分。<code>宏的名字通常我们约定是全部由大写字母组成</code>。</p><p>2.宏定义只是简单地进行替换，并且由于预处理是在编译之前进行，而编译工作的任务之一是语法检查，所以<code>编译器不会对宏定义进行语法检查</code>。</p><p>3<code>宏定义不是说明或语句，在末尾不必加分号</code>。</p><p>4.宏定义的作用域是从定义的位置开始到整个程序结束。</p><p>5.可以用<code>#undef</code>来终止宏定义的作用域。</p><p>6.宏定义允许嵌套。</p><p>对于5我们来举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">float</span> s;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入半径:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;r);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PI<span class="comment">//使得PI的作用域终结于此</span></span></span><br><span class="line">    s = PI * r * r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;圆的面积是:%.2f&quot;</span>, s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于5的用法可以使得PI的作用域终结于对应的那一行。</p><p>输出之后报错信息如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301210922895.png" alt="image-20230121092216849"></p><p>对于6我们来举个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R 6371</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V PI *R *R *R * 4 / 3<span class="comment">//对于宏定义的嵌套</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;地球的体积大概是:%.2f&quot;</span>, V);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301210926218.png" alt="image-20230121092646152"></p><h2 id="②带参数的宏定义"><a href="#②带参数的宏定义" class="headerlink" title="②带参数的宏定义"></a>②带参数的宏定义</h2><p>对于带参数的宏定义，我们先看下面的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大的数是:%d&quot;</span>, MAX(x, y));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显这个是在宏定义MAX中带了参数x，y然后根据三目运算符来进行比较x和y的大小，这个代码的输出结果如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301210939370.png" alt="image-20230121093949294"></p><p>看到这里你们是否发现这是用宏定义写了比较两个数大小的函数，但是宏定义和函数可是有着本质的区别，比如函数一般是带着相应的类型，比如浮点型，整形等等，而宏定义却不是如此。</p><p>关于带参数的宏定义我们还需要注意的是，对于我上面的代码为什么要加个括号？这是不是多次一举，那请我们看下面的这个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) x*x</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该整数的平分是:%d&quot;</span>,SQUARE(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;该(整数+1)的平方是%d&quot;</span>,SQUARE(x+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于该代码的输出结果如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301210948589.png" alt="image-20230121094848521"></p><p> 可以发现对于x+1的运算结果其实应该是36，但是这里却变成了11,其实是因为宏定义中没有加入()而导致运算为<code>x+1*x+1 = 5+5*1+1=11</code>所以括号虽然没有必要，但是还是需要加上。</p><h2 id="③-和"><a href="#③-和" class="headerlink" title="③ # 和"></a>③ # 和</h2><p>**#<strong>和</strong>##**是预处理运算符。</p><p><strong>#</strong></p><p>在带参数的宏定义中，**#**运算符后面应该跟一个参数，预处理器会把这个参数转换为一个字符串。</p><p>比如以下的一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR(s) # s</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,STR(hello bg.luoxi.work !!!));<span class="comment">//将hello bg.luoxi.work变成字符串。   </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301221050216.png" alt="image-20230122105005106"></p><p><strong>##</strong></p><p>**##**运算符被称为记号<code>连接运算符</code>，比如我们可以使用##运算符<code>连接两个参数</code>。</p><p>比如以下的一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOGETHERE(x, y) x##y</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, TOGETHERE(<span class="number">2</span>, <span class="number">50</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301221050700.png" alt="image-20230122105059635"></p>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="c语言" scheme="https://bg.luoxi.work/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://bg.luoxi.work/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>生存期和存储类型</title>
    <link href="https://bg.luoxi.work/2023/01/19/2023/Mon/5/"/>
    <id>https://bg.luoxi.work/2023/01/19/2023/Mon/5/</id>
    <published>2023-01-19T08:00:00.000Z</published>
    <updated>2023-01-20T16:04:01.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="生存期和存储类型"><a href="#生存期和存储类型" class="headerlink" title="生存期和存储类型"></a>生存期和存储类型</h1><h2 id="①-生存期"><a href="#①-生存期" class="headerlink" title="① 生存期"></a>① 生存期</h2><h3 id="（1）种类"><a href="#（1）种类" class="headerlink" title="（1）种类"></a>（1）种类</h3><p>C语言的变量拥有两种生存期</p><p>– <strong>静态存储期 (static storage duration)</strong></p><p>– <strong>自动存储期 (automatic storage duration)</strong></p><h3 id="（2）区别"><a href="#（2）区别" class="headerlink" title="（2）区别"></a>（2）区别</h3><p>一般来说，具有文件作用域的变量属于<code>静态存储期</code>，函数也属于静态存储期。属于静态存储期的变量在程序执行期间将一直占据存储空间，直到<code>程序关闭才释放</code>。</p><p>具有代码块作用域的变量一般情况下属于自动存储期。属于自动存储期的变量在代码结束时将自动释放存储空间。 </p><h3 id="（3）例子"><a href="#（3）例子" class="headerlink" title="（3）例子"></a>（3）例子</h3><p>以下用一串代码来举个例子，便于区分它们</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> A;        <span class="comment">// 静态存储器（具有文件作用域）</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> B; <span class="comment">// 静态存储器（具有文件作用域）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> C; <span class="comment">// 静态存储器（具有文件作用域）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> <span class="comment">// 静态存储器（具有文件作用域）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c; <span class="comment">// 自动存储期（具有代码块作用域）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// 静态存储器（具有文件作用域）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k; <span class="comment">// 自动存储期（具有代码块作用域）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">// 自动存储期（具有代码块作用域）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="②存储类型"><a href="#②存储类型" class="headerlink" title="②存储类型"></a>②存储类型</h2><h3 id="（1）种类-1"><a href="#（1）种类-1" class="headerlink" title="（1）种类"></a>（1）种类</h3><p>存储类型其实是指存储变量值的内存类型，C语言提供了5种不同的存储类型，它们分别是:<code>auto , register , static , extern , typedef</code></p><h3 id="（2）自动变量-auto"><a href="#（2）自动变量-auto" class="headerlink" title="（2）自动变量(auto)"></a>（2）自动变量(auto)</h3><p>在<code>代码块</code>种声明变量默认的存储类型就是自动变量，使用关键字auto来描述。</p><p>比如以下举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> a, b, c; <span class="comment">// 一般不写auto</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，有时候auto也有一定的作用，如果我们想要<code>局部变量屏蔽全局变量</code>的话，此时可以在变量名前面加上auto，比如以下例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">in i;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过一般不推荐这样做</p><h3 id="（3）寄存器变量-register"><a href="#（3）寄存器变量-register" class="headerlink" title="（3）寄存器变量(register)"></a>（3）寄存器变量(register)</h3><p>将一个变量声明为寄存器变量，那么该变量就有可能被存放于CPU的寄存器中。</p><p>寄存器变量和自动变量在很多方面都是一样的，它们都拥有代码块作用域，自动存储期和空连接属性。</p><p>不过有一点需要注意的是，当你将变量声明为寄存器变量时，那么你就无法通过取地址运算符获得该变量的地址。 </p><p>以下用一个例子帮忙理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> a = <span class="number">114514</span>;</span><br><span class="line">    printff(<span class="string">&quot;&amp;a = %p&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这串代码在编译器中运行就会导致报错，报错信息如下。</p><p><img src="https://s1.vika.cn/space/2023/01/19/de347d6adc00464ca3bd653c339485a9" alt="image-20230119014942898"></p><h3 id="（4）静态局部变量-static"><a href="#（4）静态局部变量-static" class="headerlink" title="（4）静态局部变量(static)"></a>（4）静态局部变量(static)</h3><p>使用static来声明局部变量，那么久可以<code>将局部变量指定为静态局部变量</code>，即它的<code>生存期从自动生存期转换为静态生存期</code>。</p><p>以下用一个例子来帮忙理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>, count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果</p><p><img src="https://s1.vika.cn/space/2023/01/19/1a463399c0ef4825ae401cfc3b5c64cb" alt="image-20230119015516944"></p><p>可以看到每次func结束调用之后count的值并没有被释放，它具有了和全局变量一样的生存期。但是要注意到的是它的<code>作用域并没有改变</code>！</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <summary type="html">2023洛希的一月份笔记内容</summary>
    
    
    
    <category term="c语言" scheme="https://bg.luoxi.work/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://bg.luoxi.work/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>作用域和链接属性</title>
    <link href="https://bg.luoxi.work/2023/01/09/2023/Mon/4/"/>
    <id>https://bg.luoxi.work/2023/01/09/2023/Mon/4/</id>
    <published>2023-01-09T08:00:00.000Z</published>
    <updated>2023-01-10T16:59:04.119Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="作用域和链接属性"><a href="#作用域和链接属性" class="headerlink" title="作用域和链接属性"></a>作用域和链接属性</h1><h2 id="①作用域的定义"><a href="#①作用域的定义" class="headerlink" title="①作用域的定义"></a>①作用域的定义</h2><p>当变量被定义在程序都是不同位置时， 它的作用范围是不一样的，这个作用范围就是我们所说的作用域。<code>C语言编译器可以确定4种不同类型的作用域:代码块作用域，文件作用域，原型作用域，函数作用域</code></p><h3 id="（1）代码块作用域-block-scope"><a href="#（1）代码块作用域-block-scope" class="headerlink" title="（1）代码块作用域(block scope)"></a>（1）代码块作用域(block scope)</h3><p>在代码块中定义变量，具有代码块作用域。<code>作用范围是从变量定义的位置开始，对标志该代码块结束的有大括号“&#125;”处。</code></p><p>尽管<code>函数的形式参数不在大括号内定义，但其同样具有代码块作用域</code>，隶属于包含函数体的代码块。以下来用一串代码举个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">114</span>; <span class="comment">// i1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1145</span>; <span class="comment">// i2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;in i2 block scope i = %d\n&quot;</span>, i);</span><br><span class="line">            <span class="type">int</span> i = <span class="number">11451</span>; <span class="comment">// i3</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i3 = %d\n&quot;</span>, i);</span><br><span class="line">        &#125; <span class="comment">// i3代码块内</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">114514</span>; <span class="comment">// i4</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i4 = %d\n&quot;</span>, i);</span><br><span class="line">        &#125; <span class="comment">// i4代码块内</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i2 = %d\n&quot;</span>, i);</span><br><span class="line">    &#125; <span class="comment">// i2代码块内</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i1 = %d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如以上的代码虽然重复定义了i，但是作用域各不相同,所以不会进行报错，在不同作用域会会打印出出不同i的值，不过在i3的代码块中如果先打印后将i赋值为11451此时在i2代码块内所以对应的i值是1145。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301101427452.png" alt="image-20230110142704337"></p><h3 id="（2）文件作用域-file-scope"><a href="#（2）文件作用域-file-scope" class="headerlink" title="（2）文件作用域(file scope)"></a>（2）文件作用域(file scope)</h3><p><code>任何在代码块之外声明的标识符都具有文件作用域</code>，<code>作用范围是从它们声明的位置开始，到文件的结尾</code>处都是可以访问的。</p><p>另外，函数名也具有文件作用域，因为函数名本来是在代码块之外。以下将用一串代码做个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>; <span class="comment">// 声明func，告诉编译器调用函数时别急着报，看看下面再说</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> count; <span class="comment">// 告诉编译器别急着报错，看看下面再说</span></span><br><span class="line">    func();</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main count = %d\n&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 定义全局变量count，文件作用域从10-14</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>    <span class="comment">// 定义函数，文件作用域从11-14</span></span><br><span class="line">&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in func count = %d\n&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上的代码，下面定义的全局变量以及函数本来文件作用域是对应定义地方向下的，但是因为前面进行了声明，所以编译器没有报错，但是文件作用域没变。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301101441452.png" alt="image-20230110144151379"></p><h3 id="（3）原型作用域-prototype-scope"><a href="#（3）原型作用域-prototype-scope" class="headerlink" title="（3）原型作用域(prototype scope)"></a>（3）原型作用域(prototype scope)</h3><p>原型作用域<code>只适用于那些在函数原型中声明的参数名</code>。函数在<code>声明的时候可以不写参数的名字（但参数类型是必须写上的）</code>，其实函数原型的参数名还可以随便写一个名字，不必与形式参数相匹配（当然，这样做无任何意义！）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span>;<span class="comment">//作用域为一个括号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> d,<span class="type">int</span> e,<span class="type">int</span> f)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）函数作用域-function-scope"><a href="#（4）函数作用域-function-scope" class="headerlink" title="（4）函数作用域(function scope)"></a>（4）函数作用域(function scope)</h3><p>函数作用域只适用于goto语句的标签，作用将goto语句的标签限制在一个函数内部，以及防止出现重名标签。</p><p>注：一般不推荐用goto语句跳来跳去，这样会<code>破坏代码的整体性</code>。</p><h2 id="②定义和声明"><a href="#②定义和声明" class="headerlink" title="②定义和声明"></a>②定义和声明</h2><p>当一个变量被<code>定义</code>的时候，<code>编译器为变量申请内存空间并填充一些值</code>。</p><p>当一个变量被<code>声明</code>的时候，<code>编译器就知道变量被定义在其他地方</code>。</p><p>声明是<code>通知编译器该变量名及相关的类型已存在</code>，不需要再为此申请内存空间。</p><p><code>局部变量即是定义又是声明</code>。</p><p><code>定义只允许一次</code>，否则就叫做重复定义某个同名变量；而<code>声明可以有很多次</code>。</p><h2 id="③链接属性"><a href="#③链接属性" class="headerlink" title="③链接属性"></a>③链接属性</h2><h3 id="（1）分类"><a href="#（1）分类" class="headerlink" title="（1）分类"></a>（1）分类</h3><p><strong>1.external（外部的）</strong></p><p>多个文件中声明的同名标识符表示同一个实体</p><p><strong>2.internal（内部的）</strong></p><p>单个文件中声明的同名标识符表示同一个实体</p><p><strong>3.none(无)</strong></p><p>声明的同名标识符被当作独立不同的实体。</p><p><strong>注：只有具备文件作用域的标识符才能拥有external或internal的链接属性，其他作用域的标识符都是none属性。默认情况下，具备文件作用域的标识符拥有external属性。也就是说该标识符允许跨文件访问。对于external属性的标识符，无论在不同文件中声明多少次，都表示一个实体。</strong></p><h3 id="（2）static"><a href="#（2）static" class="headerlink" title="（2）static"></a>（2）static</h3><p>使用static关键字可以使得原先拥有external属性的标识符变为internal属性。这里有两点需要注意。</p><p>1.使用static关键字修改链接属性，<code>只对具有文件作用域的标识符生效</code>（对于拥有其他作用域的标识符是另一种功能）</p><p>2.<code>链接属性只能修改一次</code>，也就是说一旦将标识符链接属性变为internal，就无法变回iexternal了。</p>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="c语言" scheme="https://bg.luoxi.work/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://bg.luoxi.work/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>指针函数和函数指针</title>
    <link href="https://bg.luoxi.work/2023/01/08/2023/Mon/3/"/>
    <id>https://bg.luoxi.work/2023/01/08/2023/Mon/3/</id>
    <published>2023-01-08T08:00:00.000Z</published>
    <updated>2023-01-08T18:53:52.890Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="指针函数和函数指针"><a href="#指针函数和函数指针" class="headerlink" title="指针函数和函数指针"></a>指针函数和函数指针</h1><h2 id="①指针函数"><a href="#①指针函数" class="headerlink" title="①指针函数"></a>①指针函数</h2><h3 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h3><p>使用<code>指针变量作为函数的返回值</code>的函数，被称为指针函数。</p><p>比如以下的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getword</span><span class="params">(<span class="type">char</span> a)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">getword</span><span class="params">(<span class="type">char</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Appel&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;None&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入该英文单词首字母(S停止):&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;该单词为: &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, getword(a));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上的代码，输出结果如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301090020850.png" alt="image-20230109002046701"></p><h3 id="（2）注意"><a href="#（2）注意" class="headerlink" title="（2）注意"></a>（2）注意</h3><p>对于以上的代码，执行似乎没有什么问题，但是对于初学指针函数经常会犯个错误，那就是<code>“不要返回局部变量的指针”</code>以下用一串代码来进行演示下为什么不能这样做，然后解释原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getword</span><span class="params">(<span class="type">char</span> a)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">getword</span><span class="params">(<span class="type">char</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a)</span><br><span class="line">    &#123;</span><br><span class="line">            str1[] = <span class="string">&quot;Appel&quot;</span>;<span class="comment">//定义局部变量（在函数内的变量为局部变量，只在函数内生效，出函数外就不能生效了。）</span></span><br><span class="line">            str2[] = <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">            str3[] = <span class="string">&quot;Cat&quot;</span>;</span><br><span class="line">            str4[] = <span class="string">&quot;None&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> str1;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> str2;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> str3;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> str4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入该英文单词首字母(S停止):&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;该单词为: &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, getword(a));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上代码，有些编译器会直接报错，因为该函数返回了一个局部变量！所以无论编译是否成功，最后的结果都会是不尽人意，<code>因为局部变量仅仅只能在函数内部生效，出了函数之后就不能生效了。</code></p><h2 id="②函数指针"><a href="#②函数指针" class="headerlink" title="②函数指针"></a>②函数指针</h2><h3 id="（1）定义-1"><a href="#（1）定义-1" class="headerlink" title="（1）定义"></a>（1）定义</h3><p>对于指针函数和函数指针，其实和前面的数组指针和指针数组一样，侧重于后面的内容，根据运算符优先级来进行定义这个是否为指针还是数组，函数和指针也同理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指针函数 -&gt; <span class="type">int</span> *<span class="title function_">p</span><span class="params">()</span>;</span><br><span class="line">函数指针 -&gt; <span class="type">int</span> (*p)();</span><br></pre></td></tr></table></figure><p>对于函数指针的作用，我们先摆出一串代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> (*fp)(<span class="type">int</span>); <span class="comment">// 定义int 函数名(int)形式函数的指针，与上面的函数形式相对应。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    fp = square; <span class="comment">// fp指针指向函数square,其实也可以对square取地址，即&amp;square，因为函数和数组类似，函数名也相当于是函数的地址。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d*%d = %d\n&quot;</span>, num, num, (*fp)(num));<span class="comment">//(*fp)(num)其实也可以写成fp(num)，但是这样写很容易让人误会fp是个函数而不是指针，所以推荐一以上写法能够更加清晰一点，是良好的编程习惯。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）函数指针作为参数"><a href="#（2）函数指针作为参数" class="headerlink" title="（2）函数指针作为参数"></a>（2）函数指针作为参数</h3><p>其实函数指针因为本身也是一个指针变量，所以函数指针也可以作为函数中参数列表中的参数之一，以下将用一个小例子来进行理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> num1, <span class="type">int</span> num2)</span><span class="comment">//定义函数calc，参数列表第一个是函数指针指向一个函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*fp)(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个整数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;num1, &amp;num2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;两数之和为:%d\n&quot;</span>, calc(add, num1, num2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;两数之差为:%d\n&quot;</span>, calc(sub, num1, num2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上代码就是定义了一个函数calc，并且它的参数列表第一个变量为整形的函数指针来进行指向函数add或者sub来进行运算，对于以上的代码的输出结果如下所示。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301090139815.png" alt="image-20230109013943748"></p><p>既然函数指针可以在函数内的参数列表中，同样它也可以作为返回值来在函数内部。</p><h3 id="（3）函数指针作为返回值"><a href="#（3）函数指针作为返回值" class="headerlink" title="（3）函数指针作为返回值"></a>（3）函数指针作为返回值</h3><p>如果要把函数指针当为返回值的话，这可就难办了，我们知道<code>函数返回值的类型由函数首部定义的类型决定</code>，那么我们该如何取些函数定义的类型呢？<br>通过上面的代码进行增加，我们可以这样写，代码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*select(<span class="type">char</span>))(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calc</span><span class="params">(<span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">// 定义函数calc，参数列表第一个是函数指针指向一个函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*fp)(num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> (*select(<span class="type">char</span> ch))(<span class="type">int</span> num1, <span class="type">int</span> num2)<span class="comment">//定义函数select根据符号返回对应函数的地址</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> add;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入式子(如1+1):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c%d&quot;</span>, &amp;num1, &amp;ch, &amp;num2);</span><br><span class="line">    fp = select(ch);<span class="comment">//select返回add或者sub地址给fp</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%c%d = %d\n&quot;</span>, num1, ch, num2, calc(fp, num1, num2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上代码，完美的阐述了这一点，其实新加的函数返回值为函数指针的作用就是把对应运算函数的地址给指针变量fp，然后就将对应的地址给calc函数的参数列表第一个来表示对应的运算。对于以上代码的输出结果如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301090252038.png"></p><p>其实对于函数select部分，我们如果将它返回结束之后其实就是最后就是一个函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*select(<span class="type">char</span> ch))(<span class="type">int</span> num1, <span class="type">int</span> num2)<span class="comment">//定义函数select根据符号返回对应函数的地址</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> add;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结束后的结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*)(<span class="type">int</span> num1, <span class="type">int</span> num2)<span class="comment">//定义函数select根据符号返回对应函数的地址</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ch)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> add;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实对应的就是一个函数指针，可能是add也有可能是sub的地址。</p>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="c语言" scheme="https://bg.luoxi.work/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://bg.luoxi.work/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>参数和指针</title>
    <link href="https://bg.luoxi.work/2023/01/06/2023/Mon/2/"/>
    <id>https://bg.luoxi.work/2023/01/06/2023/Mon/2/</id>
    <published>2023-01-06T08:00:00.000Z</published>
    <updated>2023-01-07T17:15:01.889Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="参数和指针"><a href="#参数和指针" class="headerlink" title="参数和指针"></a>参数和指针</h1><h2 id="①参数"><a href="#①参数" class="headerlink" title="①参数"></a>①参数</h2><h3 id="（1）形参和实参"><a href="#（1）形参和实参" class="headerlink" title="（1）形参和实参"></a>（1）形参和实参</h3><p>对于形参和实参的认识，我们可以根据以下的代码来进行理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//括号内的是形参</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x+y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sum(<span class="number">3.5</span>);<span class="comment">//当函数被调用的时候，实参会传递给形参</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：形参只有在函数内部才有效！出了函数就什么都不是！</strong></p><h3 id="（2）可变参数"><a href="#（2）可变参数" class="headerlink" title="（2）可变参数"></a>（2）可变参数</h3><p>如果想要使用可变参数，需要引用头文件stdarg.h，下面简单概述并用代码理解以下可变参数的四个相关的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line">va_list 列表名;<span class="comment">//定义可变参数列表</span></span><br><span class="line">va-start(列表名,参数个数);<span class="comment">//初始化参数列表</span></span><br><span class="line">va-arg(列表名，参数数据类型);<span class="comment">//获取后面每一个参数的值</span></span><br><span class="line">va_end(列表名)<span class="comment">//关闭参数列表</span></span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n,...)</span>;<span class="comment">//定义sum函数，n表示参数的数量，...为占位符表示参数数目不确定。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n,...)</span><span class="comment">//这个参数列表不仅仅包括整形，字符串等等都行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,sum = <span class="number">0</span>;</span><br><span class="line">    va_list vap;<span class="comment">//定义可变参数列表。</span></span><br><span class="line">    va_start(vap,n);<span class="comment">//将数目为n个参数的参数列表vap进行初始化。</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">sum += va_arg(vap,<span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(vap);<span class="comment">//关闭参数列表</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">result = sum(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>,result);</span><br><span class="line">    result = sum(<span class="number">6</span>,<span class="number">-3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">-3</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>,result);</span><br><span class="line">    result = sum(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = %d\n&quot;</span>,result);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上的代码输出结果入地下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301080111189.png" alt="image-20230108011149118"></p><h2 id="②指针的运用"><a href="#②指针的运用" class="headerlink" title="②指针的运用"></a>②指针的运用</h2><h3 id="（1）传值和传址"><a href="#（1）传值和传址" class="headerlink" title="（1）传值和传址"></a>（1）传值和传址</h3><h3 id="1-传值的定义"><a href="#1-传值的定义" class="headerlink" title="1.传值的定义"></a>1.传值的定义</h3><p>通过上面形参和实参的例子我们可以发现，在这个过程中有个传递的内容，就说实参的值给了形参，而这就是我们常说的传值。它的定义<code>就是使用变量、常量、数组等作为函数的参数。实际是将实参的值复制到形参相应的存储单元中，即形参和实参分别占用不同的存储单元。</code></p><h3 id="2-传值的特点"><a href="#2-传值的特点" class="headerlink" title="2.传值的特点"></a>2.传值的特点</h3><p>传值的特点是<code>单向传递</code>，即主调函数被调用时给形参分配存储单元，把实参的值传递给形参，在调用结束后，形参的存储单元被<code>释放</code>，而形参值的任何变化都<code>不会影响</code>到实参的值，实参的存储单元仍保留并维持数值不变。</p><p>对于传值我们发现，形参的任何变化都不会影响到实参的值，它被定死在了对应的函数区域了，那么传址呢？</p><h3 id="3-传址的定义"><a href="#3-传址的定义" class="headerlink" title="3.传址的定义"></a>3.传址的定义</h3><p>通过了解了传值我们或许固定了一个思维，就是真的形参不会影响到实参吗？实际上并不是，而址传递却并不如此。我们都知道在C语言中数组名就代表数组的首地址。<code>所谓的址传递，指的就是函数的参数是数组名或者指针。传递的是数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，形参和实参占用相同的存储单元，即形参和实参是相同的。</code></p><h3 id="4-传址的特点"><a href="#4-传址的特点" class="headerlink" title="4.传址的特点"></a>4.传址的特点</h3><p><code>形参并不存在存储空间</code>，编译系统不为形参数组分配内存。因此在数组名或指针作函数参数时所进行的传送只是地址传送，形参在取得该地址之后，与<code>实参共同拥有一段内存空间，形参的变化也就是实参的变化</code>。</p><p>以下，我们将对上面的一些概念加上例子进行理解。</p><h3 id="5-例子（区别传值和传址）"><a href="#5-例子（区别传值和传址）" class="headerlink" title="5.例子（区别传值和传址）"></a>5.例子（区别传值和传址）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in swap funk swap before a=%d,b=%d\n&quot;</span>, a, b);<span class="comment">//在swap函数打印传值之后的a和b的值</span></span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in swap funk swap after a=%d,b=%d\n&quot;</span>, a, b);<span class="comment">//在swap函数打印传值之后交换之后的a和b的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">114514</span>, b = <span class="number">1919810</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main funk swap before a=%d,b=%d\n&quot;</span>, a, b);<span class="comment">//在main函数打印调用函数之前的a和b的值</span></span><br><span class="line">    swap(a, b);<span class="comment">//调用swap函数进行值传递将a和b的值传递给swap函数内的形参</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main funk swap after a=%d,b=%d\n&quot;</span>, a, b);<span class="comment">//在main函数打印调用函数之后的a和b的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下图所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301080010907.png" alt="image-20230108001054804"></p><p>如果我们用传址的思路，这代码应该怎么写？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in swap funk swap before a=%d,b=%d\n&quot;</span>, *a, *b); <span class="comment">// 在swap函数打印传值之后的a和b的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = *a;</span><br><span class="line">        *a = *b;</span><br><span class="line">        *b = temp;</span><br><span class="line">    &#125;<span class="comment">//将a和b地址内的元素取出来进行交换，改变地址内的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in swap funk swap after a=%d,b=%d\n&quot;</span>, *a, *b); <span class="comment">// 在swap函数打印传值之后交换之后的a和b的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">114514</span>, b = <span class="number">1919810</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main funk swap before a=%d,b=%d\n&quot;</span>, a, b); <span class="comment">// 在main函数打印调用函数之前的a和b的值</span></span><br><span class="line">    swap(&amp;a, &amp;b);                                         <span class="comment">// 调用swap函数进行值传递将&amp;a和&amp;b的址传递给swap函数内的形参</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main funk swap after a=%d,b=%d\n&quot;</span>, a, b);  <span class="comment">// 在main函数打印调用函数之后的a和b的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301080018042.png" alt="image-20230108001845971"></p><p>我们可以清晰的发现，传值和传址的根本区别就是：<code>能否对实参产生影响</code></p><h3 id="（2）传数组"><a href="#（2）传数组" class="headerlink" title="（2）传数组"></a>（2）传数组</h3><p>对于传数组，它和传址很像，它也可以改变形参的值，因为我们之前学过，数组名本身也就是一个地址，所以我们真正传递过去的其实就是地址。以下用一个例子来方便理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getarr</span><span class="params">(<span class="type">int</span> a[<span class="number">10</span>])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getarr</span><span class="params">(<span class="type">int</span> a[<span class="number">10</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">114514</span>;</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">1919810</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in getarr funk a[10] output:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    getarr(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main funk a[10] output:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 以下为输出结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301080037783.png" alt="image-20230108003756695"></p><p>我们可以看到实参也受到了影响，其实这是因为我们传数组也是传的指针，而且在函数内更改了对应地址的值，所以实参受到了影响。</p><p>如果你对以上的代码有很大的疑惑，没关系，下面的例子绝对能够证明传递过去的实际上就是指针！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getarr</span><span class="params">(<span class="type">int</span> b[<span class="number">10</span>])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getarr</span><span class="params">(<span class="type">int</span> b[<span class="number">10</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in getarr funk b[10] sizeof:%d\n&quot;</span>, <span class="keyword">sizeof</span>(b)); <span class="comment">// 用sizeof计算数组b的字节来确定它是指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    getarr(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in main funk a[10] sizeof:%d\n&quot;</span>, <span class="keyword">sizeof</span>(a)); <span class="comment">// 用sizeof计算数组a的字节来确定它是数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下为输出结果</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301080048739.png" alt="image-20230108004856670"></p>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="c语言" scheme="https://bg.luoxi.work/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://bg.luoxi.work/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="https://bg.luoxi.work/2023/01/03/2023/Mon/1/"/>
    <id>https://bg.luoxi.work/2023/01/03/2023/Mon/1/</id>
    <published>2023-01-03T08:00:00.000Z</published>
    <updated>2023-01-04T17:23:46.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="①目前开发的问题"><a href="#①目前开发的问题" class="headerlink" title="①目前开发的问题"></a>①目前开发的问题</h2><p><strong>随着程序规模的变大：</strong></p><p>1.<code>main函数变得相当冗杂</code></p><p>2.程序复杂度不断提高</p><p>3.代码前后关联度高，修改代码往往牵一发而动全身</p><p>4.变量的命名都成了问题</p><p>5.为了在程序中多次实现某些功能，不得不重复写相同的代码</p><h2 id="②主函数外的函数"><a href="#②主函数外的函数" class="headerlink" title="②主函数外的函数"></a>②主函数外的函数</h2><h3 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型名一定程度决定了返回值。</span></span><br><span class="line">类型名 函数名（参数列表）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//执行过程</span></span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）声明"><a href="#（2）声明" class="headerlink" title="（2）声明"></a>（2）声明</h3><p>所谓声明，就说高速编译器我们使用这个函数，你现在没用找到它千万不要着急报错，稍后就把定义补上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 函数名（参数列表）;<span class="comment">//可以省略，但是不建议。</span></span><br></pre></td></tr></table></figure><p><strong>注意：因为编译器是从下到上执行，如果你的函数定义写在主函数下方，建议还是要把定义写上，这是给良好的习惯，</strong></p><h3 id="（3）函数的参数和返回值"><a href="#（3）函数的参数和返回值" class="headerlink" title="（3）函数的参数和返回值"></a>（3）函数的参数和返回值</h3><p>函数的参数就说参数列表对应的<code>形式参数</code>，返回值则是代表这个<code>函数的结束</code>，返回为某值。但是一定要注意<code>函数返回值的类型由函数首部定义的类型决定</code>！</p><h2 id="（4）例子"><a href="#（4）例子" class="headerlink" title="（4）例子"></a>（4）例子</h2><p>对于①中5所提到的，如果我们想要重复打印一段文字，应该怎么做呢？先举个简单的小例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//声明函数printc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printc</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//定义函数printc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">printc();<span class="comment">//调用函数printc</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个代码，我们在主函数外定义了一个函数printc，让它帮我们打印一些内容，以下为输出结果。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040047979.png" alt="image-20230104004745848"></p><p>如果我们想要这个函数的内容执行三次，只需要额外再调用两次就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printc</span><span class="params">()</span>;<span class="comment">//定义函数print-c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">printc();<span class="comment">//调用函数printc</span></span><br><span class="line">printc();</span><br><span class="line">printc();</span><br><span class="line"><span class="comment">//调用三次printc</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040049509.png" alt="image-20230104004928446"></p><p>但是，如果我们想要它无限调用这个函数的话，我们该怎么办呢？这就不得不用到所谓的<code>递归</code>思想了。递归和迭代有一点相似，但是它们不完全相同。</p><p><strong>递归:函数直接或间接调用函数自身,<code>直到满足终止条件</code>,再<code>逐层回归</code>。</strong></p><p><strong>迭代:利用已知的变量值,不断用变量的旧值递推新值,<code>直到到达结束状态</code></strong></p><p>所以，如果我们想要无限调用函数printc只需要在printc里面继续调用就行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printc</span><span class="params">()</span>;<span class="comment">//定义函数print-c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">printc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">printc();<span class="comment">//调用函数printc</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040053178.png" alt="image-20230104005317112"></p><p>递归的思想在很多地方也很适用，不过有一个非常经典的例子是有关一个小游戏名叫<code>汉诺塔</code>。</p><p>对于以上的例子是函数一个简单的小例子，如果我们想写一个函数帮忙我们计算阶乘的话？该如何写呢？代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> s = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    s *= i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回值必须是整数</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="comment">// 在printf里面调用fact函数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;它的阶乘为%d\n&quot;</span>, fact(n));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上代码，我们输入5来测试下。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040145060.png" alt="image-20230104014550984"></p><h2 id="③递归思想——汉诺塔问题"><a href="#③递归思想——汉诺塔问题" class="headerlink" title="③递归思想——汉诺塔问题"></a>③递归思想——汉诺塔问题</h2><p><strong>以下是一个汉诺塔的有关问题</strong>:</p><p>  相传在古印度圣庙中，有一种被称为汉诺塔的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘。                                          </p><p>游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。</p><p>如果，我们将金盘的数量定义为n，要求用代码实现移动过程，该怎么办呢？</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040101310.png" alt="image-20230104010148248"></p><p><strong>思路：</strong></p><p>1.如果要<strong>把A中的n个金盘借助B移动到C去</strong>，且满足小在上大在下的规则的话，我们第一肯定是要把<code>n盘上面的n-1个金盘借助C移动到B</code>，然后就可以将n盘移动到C去了。</p><p>2.此时问题变成了要<strong>把B中的n-1个金盘借助A移动到C去</strong>，则是要把<code>n-2个金盘借助C移动到A去</code>，然后就可以把n-1盘移动到C去了。</p><p>3.此时问题就变成了<strong>把A中的n-2个金盘借助B移动到C去</strong>，则思路一样，是要把<code>n-3个金盘借助C移动到B去</code>，然后就可以将n-2盘移动到C去了。</p><p>通过上面的3次分析，我们发现其实这个问题的本质就是每个分析标注的两点以及下个分析的第一个标注点，此时核心问题为如下三点。</p><p><strong>①把A中的n个金盘借助B移动到C去</strong></p><p><strong>②n盘上面的n-1个金盘借助C移动到B</strong></p><p><strong>③把B中的n-1个金盘借助A移动到C去</strong></p><p>那我们应该如何去用代码实现呢？</p><p>此中我们需要定义金盘的数量这个变量，以及表述A,B,C三个柱子的变量。然后根据<code>递归思想</code>（根据上面分析，问题是一种重复的轮回。）去实现它。</p><p><strong>题解：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义一个实现这个流程的函数，函数括号的意思是(金盘数量，柱子a(起始)，柱子b(借助)，柱子c(终点))</span></span><br><span class="line"><span class="comment">// 而后面的三个字符变量后面的思路就是借助柱子b把金盘从柱子a移动到柱子c。</span></span><br><span class="line"><span class="comment">// 注意：前往别把这三个柱子定死理解为就说ABC柱子，后面会有调用函数的交换。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">halot</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">halot</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> a, <span class="type">char</span> b, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 当此时只剩下一个盘的时候，只需要完成此时的目标，比如n-1个盘子以及到B柱子，这里n盘这一个盘就直接去目标。</span></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 表示这个移动的过程，根据调用这个函数就是为了实现移动的这个过程。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c --＞ %c\n&quot;</span>, a, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 交换b和c的字符导致字符变量a，b，c并非代表了柱子ABC，但是思路还是和上面所说一样</span></span><br><span class="line">    halot(n - <span class="number">1</span>, a, c, b);</span><br><span class="line">    <span class="comment">// 表示这个移动的过程，根据调用这个函数就是为了实现移动的这个过程。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c --＞ %c\n&quot;</span>, a, c);</span><br><span class="line">    <span class="comment">// 交换b和a的字符导致字符变量a，b，c并非代表了柱子ABC，但是思路还是和上面所说一样</span></span><br><span class="line">    halot(n - <span class="number">1</span>, b, a, c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入金盘的数量:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  halot(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>); <span class="comment">// 将形参a命定为柱子A，形参b命定为柱子B，形参c命定为柱子C。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>请不要定死了字符变量a，b，c所代表的柱子，它们在调用函数的时候会改变，但是<strong>核心思想永远不变</strong>！</p><p>代码的输出结果如下所示，测试数据为3</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040126575.png" alt="image-20230104012610506"></p><p>最后根据这个步骤，游戏圆满成功！<br><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202301040127312.png" alt="image-20230104012701255"></p>]]></content>
    
    
    <summary type="html">洛希的一月份笔记内容</summary>
    
    
    
    <category term="c语言" scheme="https://bg.luoxi.work/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://bg.luoxi.work/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>常量和指针</title>
    <link href="https://bg.luoxi.work/2022/12/30/DEnot/10/"/>
    <id>https://bg.luoxi.work/2022/12/30/DEnot/10/</id>
    <published>2022-12-30T08:00:00.000Z</published>
    <updated>2022-12-30T16:56:18.408Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常量和指针"><a href="#常量和指针" class="headerlink" title="常量和指针"></a>常量和指针</h1><h2 id="①常量"><a href="#①常量" class="headerlink" title="①常量"></a>①常量</h2><p>常量是编程中非常让人熟悉且重要的概念，以下是常见的几种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">520</span>，<span class="string">&#x27;a&#x27;</span>,<span class="number">3.14</span><span class="comment">//常见常量</span></span><br><span class="line">或者如下</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRICE 520</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A <span class="string">&#x27;a&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure><p>其实用<code>const</code>关键字修饰的也被称为常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> price = <span class="number">520</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//const使得变量也拥有了常量的特性</span></span><br></pre></td></tr></table></figure><p>以下举个例子来进行理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,pi);<span class="comment">//该值可以被正常打印出来</span></span><br><span class="line">    pi=<span class="number">3.1415</span>;<span class="comment">//尝试修改</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们根据以上代码一样尝试修改pi的值，程序的输出结果会怎么样呢？</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212302348898.png" alt="image-20221230234846776"></p><p>程序很明显就会发生报错，因为const修饰的变量pi不能被修改了，而表达式左边的<code>左值必须是可以修改的变量</code>。</p><h2 id="②指向常量的指针"><a href="#②指向常量的指针" class="headerlink" title="②指向常量的指针"></a>②指向常量的指针</h2><p>对于上面的常量或许看起来没有那么复制，但是如果它跟指针联系一起那就复杂很多了，当一个指针指向一个常量的时候会发生什么呢？请看下面的例子。</p><h3 id="（1）例子"><a href="#（1）例子" class="headerlink" title="（1）例子"></a>（1）例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">114514</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cnum = <span class="number">1919810</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *pc = &amp;cnum;<span class="comment">//定义了指向常量的指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cnum:%d &amp;cnum:%p\n&quot;</span>,cnum,&amp;cnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pc:%d pc:%p\n&quot;</span>,*pc,pc);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上的代码的输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212310009189.png" alt="image-20221231000912095"></p><p>可以发现它们所打印出来的值一模一样，但是我们如果企图将pc进行解引用然后修改它的值会发生什么呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">114514</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cnum = <span class="number">1919810</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *pc = &amp;cnum;<span class="comment">//定义了指向常量的指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cnum:%d &amp;cnum:%p\n&quot;</span>,cnum,&amp;cnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pc:%d pc:%p\n&quot;</span>,*pc,pc);</span><br><span class="line">    *pc = <span class="number">114514</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212310010133.png" alt="image-20221231001028090"></p><p>程序会出现和之前一样的错误，但是，我们如果只修改它的地址呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">114514</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cnum = <span class="number">1919810</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *pc = &amp;cnum;<span class="comment">//定义了指向常量的指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cnum:%d &amp;cnum:%p\n&quot;</span>,cnum,&amp;cnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pc:%d pc:%p\n&quot;</span>,*pc,pc);</span><br><span class="line">    pc = &amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num:%d &amp;num:%p\n&quot;</span>,num,&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pc:%d pc:%p\n&quot;</span>,*pc,pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212310011903.png" alt="image-20221231001157840"></p><p>可以发现是允许这样写的，而且我们其实是可以修改num的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">114514</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cnum = <span class="number">1919810</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *pc = &amp;cnum;<span class="comment">//定义了指向常量的指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cnum:%d &amp;cnum:%p\n&quot;</span>,cnum,&amp;cnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pc:%d pc:%p\n&quot;</span>,*pc,pc);</span><br><span class="line">    pc = &amp;num;</span><br><span class="line">    num = <span class="number">1919810</span>;<span class="comment">//修改num的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num:%d &amp;num:%p\n&quot;</span>,num,&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pc:%d pc:%p\n&quot;</span>,*pc,pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212310014338.png" alt="image-20221231001425274"></p><h3 id="（2）总结"><a href="#（2）总结" class="headerlink" title="（2）总结"></a>（2）总结</h3><p>1.指针可以修改为指向不同的常量</p><p>2.指针可以修改为指向不同的变量</p><p>3.可以通过解引用来读取指针指向的数据</p><p>4.不可以通过解引用修改指针指向的数据</p><h2 id="③常量指针"><a href="#③常量指针" class="headerlink" title="③常量指针"></a>③常量指针</h2><p>常量指针和前面的指向常量的指针的<code>区别就在于const的位置</code>，因为表达式是从左往右读的，如果const在int前面或者星号左侧，则const就是用来修饰指针所指向的变量(既*p),即指针指向为常量;如果const位于星号的右侧,const就是修饰指针本身(既p),即指针本身指向的地址是常量。以下来举个例子。</p><h3 id="（1）例子-1"><a href="#（1）例子-1" class="headerlink" title="（1）例子"></a>（1）例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">114514</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cnum = <span class="number">1919810</span>;</span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> p =&amp;num;<span class="comment">//指向非常量的常量指针</span></span><br><span class="line">    *p =<span class="number">1919810</span>;<span class="comment">//来测试是否可以进行改变</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num:%d *p:%d\n&quot;</span>,num,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212310027825.png" alt="image-20221231002714757"></p><p>可以发现，通过解引用改变num的值是允许的，但是如果改变p所指向的地址呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">114514</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cnum = <span class="number">1919810</span>;</span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> p =&amp;num;<span class="comment">//指向非常量的常量指针</span></span><br><span class="line">    *p =<span class="number">1919810</span>;<span class="comment">//来测试是否可以进行改变</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num:%d *p:%d\n&quot;</span>,num,*p);</span><br><span class="line">    p = &amp;cnum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cnum:%d *p:%d\n&quot;</span>,cnum,*p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212310028352.png" alt="image-20221231002858314"></p><p>可以发现又出现了和之前一样的报错信息。</p><p>但是我们如果把常量指针指向常量会发生什么呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">114514</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cnum = <span class="number">1919810</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p =&amp;cnum;<span class="comment">//指向常量的常量指针</span></span><br><span class="line">    *p =<span class="number">114514</span>;<span class="comment">//来测试是否可以进行改变</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cnum:%d *p:%d\n&quot;</span>,cnum,*p);</span><br><span class="line">    p = &amp;num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212310043764.png" alt="image-20221231004323720"></p><p>编译器也会毫不留情将我们拒之门外，</p><h3 id="（2）总结-1"><a href="#（2）总结-1" class="headerlink" title="（2）总结"></a>（2）总结</h3><p><strong>1.指向非常量的常量指针</strong></p><p>①指针自身不可以被修改</p><p>②指针指向的值可以被修改</p><p><strong>2.指向常量的常量指针</strong></p><p>①指针自身不可以被修改</p><p>②指针指向的值也不可以被修改</p><h2 id="④指向”指向常量的常量指针“的指针"><a href="#④指向”指向常量的常量指针“的指针" class="headerlink" title="④指向”指向常量的常量指针“的指针"></a>④指向”指向常量的常量指针“的指针</h2><p>对于这个标题，可能会感觉有点绕口或者套娃，其实对于我们上面写的那一串代码就是指向常量的常量指针呢，如果我们需要再来个指针指向它，其实可以这样写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1919810</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p =&amp;num;<span class="comment">//指向常量的常量指针</span></span><br><span class="line">    <span class="type">int</span> **pp =&amp;p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pp:%p &amp;p:%p\n&quot;</span>,pp,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pp:%p p:%p &amp;num:%p\n&quot;</span>,*pp,p,&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**pp:%d *p:%d num:%d\n&quot;</span>,**pp,*p,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这样写的话输出结果会怎么样呢？</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212310053746.png" alt="image-20221231005347710"></p><p>我们会发现，编译器会报错，因为我们指向的是一个指向常量的常量指针，所以如果我们要用一个指针来指向它，就必须用相似的形式，修改的形式如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1919810</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p =&amp;num;<span class="comment">//指向常量的常量指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> *pp =&amp;p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pp:%p &amp;p:%p\n&quot;</span>,pp,&amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*pp:%p p:%p &amp;num:%p\n&quot;</span>,*pp,p,&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**pp:%d *p:%d num:%d\n&quot;</span>,**pp,*p,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212310052557.png" alt="image-20221231005213478"></p>]]></content>
    
    
    <summary type="html">洛希的十二月份笔记内容</summary>
    
    
    
    <category term="c语言" scheme="https://bg.luoxi.work/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://bg.luoxi.work/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>指向指针的指针</title>
    <link href="https://bg.luoxi.work/2022/12/29/DEnot/9/"/>
    <id>https://bg.luoxi.work/2022/12/29/DEnot/9/</id>
    <published>2022-12-29T08:00:00.000Z</published>
    <updated>2022-12-29T13:27:01.507Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h1><h2 id="①理解"><a href="#①理解" class="headerlink" title="①理解"></a>①理解</h2><p>对于指向指针的指针，我们听这个名字或许感觉非常的绕口，所以以下我将用一个例子来进行帮忙理解，顺便配有相应的图解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这串代码，我们或许不会感到陌生，它的大概图解如下所示。</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212282241188.png" alt="image-20221228224131135"></p><p>但是，如果我们在定义一个 int **pp = &amp;p呢？代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num;</span><br><span class="line"><span class="type">int</span> **pp = &amp;p;<span class="comment">//指向指针p的地址</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于这串新增的代码的图解如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212282244336.png" alt="image-20221228224403289"></p><p>对于上面的例子其实我们不难发现，当我们在定义一个指针的时候，它就已经教我们该如何进行解引用了，比如定义指针p就是int  *p,而当我们定义指针pp的时候是int **pp；</p><p>对于以上的代码，我们来进行打印以下，来看看是否如上面所说的一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;num;</span><br><span class="line"><span class="type">int</span> **pp = &amp;p;<span class="comment">//指向指针p的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num: %d\n&quot;</span>,num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p: %d\n&quot;</span>,*p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;**pp: %d\n&quot;</span>,**pp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;p: %p pp: %p\n&quot;</span>,&amp;p,pp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;num: %p p: %p *pp:%p\n&quot;</span>,&amp;num,p,*pp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212282252544.png" alt="image-20221228225229478"></p><h2 id="②指针数组和指向指针的指针"><a href="#②指针数组和指向指针的指针" class="headerlink" title="②指针数组和指向指针的指针"></a>②指针数组和指向指针的指针</h2><p>对于指针数组和指向指针的指针，先用一串代码来举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* lgal[] = &#123;</span><br><span class="line"><span class="string">&quot;《ATRI》&quot;</span>,</span><br><span class="line"><span class="string">&quot;《星空列车与白的旅行》&quot;</span>,</span><br><span class="line"><span class="string">&quot;《昙花》&quot;</span>,</span><br><span class="line"><span class="string">&quot;《茸雪》&quot;</span> &#125;;<span class="comment">//定义一个指针数组存放喜欢的galgame</span></span><br><span class="line"><span class="type">char</span> **rbgal[<span class="number">2</span>];<span class="comment">//定义一个指向指针的指针存放日本galgame</span></span><br><span class="line"><span class="type">char</span> **zggal[<span class="number">2</span>];<span class="comment">//定义一个指向指针的指针存放中国galgame</span></span><br><span class="line">rbgal[<span class="number">0</span>] = &amp;lgal[<span class="number">0</span>];<span class="comment">//存放字符串指针的地址</span></span><br><span class="line">rbgal[<span class="number">1</span>] = &amp;lgal[<span class="number">1</span>];</span><br><span class="line">zggal[<span class="number">0</span>] = &amp;lgal[<span class="number">2</span>];</span><br><span class="line">zggal[<span class="number">1</span>] = &amp;lgal[<span class="number">3</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;洛希喜欢的日本galgame是:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt; <span class="number">2</span>; m++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *rbgal[m]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;洛希喜欢的中国galgame是:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">1</span>; n &lt; <span class="number">2</span>; n++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *zggal[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上的代码的输出结果如下所示</p><p><img src="https://luoxi2334.oss-cn-shanghai.aliyuncs.com/luoxi-picture/202212291910132.png" alt="image-20221229191007998"></p><p>对于这样写有三个好处</p><p>1.避免重复的分配内存</p><p>2.只需要进行一处修改</p><p>3.代码的灵活性和安全性都有了显著的提高！</p>]]></content>
    
    
    <summary type="html">洛希的十二月份笔记内容</summary>
    
    
    
    <category term="c语言" scheme="https://bg.luoxi.work/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://bg.luoxi.work/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
